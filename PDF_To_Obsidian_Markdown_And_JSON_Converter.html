<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF to Obsidian Markdown & JSON Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 0;
            min-height: 600px;
        }

        .sidebar {
            background: #f8f9fa;
            padding: 25px;
            border-right: 1px solid #e0e0e0;
        }

        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .section h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: #667eea;
            color: white;
            text-align: center;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .file-input-label:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 6px;
            font-size: 13px;
            color: #333;
            word-break: break-all;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            font-weight: 500;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .input-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            cursor: pointer;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 60px;
        }

        .btn {
            width: 100%;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #218838;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-section {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .content-area {
            padding: 25px;
            overflow-y: auto;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .preview-box {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.9;
        }

        .download-section {
            background: #f0f7ff;
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .download-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .sidebar {
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
            }
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ PDF to Obsidian Markdown & JSON Converter</h1>
            <p>Convert PDF documents to Obsidian-formatted Markdown, JSON, and HTML with image extraction</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="section">
                    <h3>üìÅ File Selection</h3>
                    <div class="file-input-wrapper">
                        <input type="file" id="pdfInput" accept=".pdf">
                        <label for="pdfInput" class="file-input-label">Choose PDF File</label>
                    </div>
                    <div id="fileInfo" class="file-info" style="display: none;"></div>
                </div>

                <div class="section">
                    <h3>‚öôÔ∏è Settings</h3>
                    <div class="input-group">
                        <label for="startPage">Start from Page:</label>
                        <input type="number" id="startPage" value="1" min="1">
                    </div>
                    <div class="input-group">
                        <label for="firstPageAs">First Page Number:</label>
                        <input type="number" id="firstPageAs" value="1" min="1">
                    </div>
                </div>

                <div class="section">
                    <h3>üîß Post-Processing</h3>
                    <div class="input-group">
                        <label>
                            <input type="checkbox" id="enablePostProcessing">
                            Enable Post-Processing
                        </label>
                    </div>
                    <div class="input-group">
                        <label>
                            <input type="checkbox" id="addSpaceBetweenScripts">
                            Add space between scripts (Latin/CJK)
                        </label>
                    </div>
                    <div class="input-group">
                        <label>
                            <input type="checkbox" id="addSpaceAroundPunctuation">
                            Add space around punctuation
                        </label>
                    </div>
                    <div class="input-group">
                        <label>
                            <input type="checkbox" id="addSpaceBeforeCapital">
                            Add space before capitals
                        </label>
                    </div>
                    <div class="input-group">
                        <label for="removeStrings" style="display: block; margin-bottom: 5px;">Remove strings (one per line):</label>
                        <textarea id="removeStrings" rows="3" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; font-family: monospace;"></textarea>
                    </div>
                </div>

                <div class="section">
                    <h3>üöÄ Process</h3>
                    <button id="convertBtn" class="btn btn-primary" disabled>Convert PDF</button>
                    <button id="cancelBtn" class="btn btn-secondary" disabled>Cancel</button>
                    
                    <div class="progress-section">
                        <div class="progress-bar">
                            <div id="progressFill" class="progress-fill"></div>
                        </div>
                        <div id="progressText" class="progress-text">Ready</div>
                    </div>
                </div>

                <div class="section">
                    <h3>üíæ Download Outputs</h3>
                    <button id="downloadAllBtn" class="btn btn-success" disabled>Download All</button>
                </div>
            </div>

            <div class="content-area">
                <div class="alert alert-info">
                    <strong>‚ÑπÔ∏è Instructions:</strong> Select a PDF file, configure settings and post-processing options, then click "Convert PDF". 
                    <br><br>
                    <strong>Post-Processing Features:</strong>
                    <ul style="margin: 10px 0 0 20px; padding: 0;">
                        <li><strong>Remove strings:</strong> Enter unwanted text (one per line) to remove from output</li>
                        <li><strong>Space between scripts:</strong> Adds space between Latin/CJK characters (e.g., <code>TrinhÂè∏È¶¨Ë≤ûtrong</code> ‚Üí <code>Trinh Âè∏È¶¨Ë≤û trong</code>)</li>
                        <li><strong>Space around punctuation:</strong> Adds space around punctuation (e.g., <code>word.Next</code> ‚Üí <code>word. Next</code>)</li>
                        <li><strong>Space before capitals:</strong> Adds space before capital letters (e.g., <code>·ªüTrung</code> ‚Üí <code>·ªü Trung</code>)</li>
                    </ul>
                    <br>
                    All outputs will be saved with proper naming: <code>[yymmddhhmm] - filename</code>
                </div>

                <div id="statsSection" style="display: none;">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="statPages">0</div>
                            <div class="stat-label">Pages Processed</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statImages">0</div>
                            <div class="stat-label">Images Extracted</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statWords">0</div>
                            <div class="stat-label">Words</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statSize">0</div>
                            <div class="stat-label">KB Total</div>
                        </div>
                    </div>
                </div>

                <div id="downloadSection" class="download-section" style="display: none;">
                    <h3 style="margin-bottom: 15px;">üì¶ Download Individual Files:</h3>
                    <div class="download-buttons">
                        <button id="downloadMdBtn" class="btn btn-primary">Download Markdown</button>
                        <button id="downloadJsonBtn" class="btn btn-primary">Download JSON</button>
                        <button id="downloadHtmlBtn" class="btn btn-primary">Download HTML</button>
                        <button id="downloadSummaryBtn" class="btn btn-primary">Download Summary</button>
                    </div>
                </div>

                <div class="tabs">
                    <button class="tab active" data-tab="markdown">Markdown Preview</button>
                    <button class="tab" data-tab="json">JSON Preview</button>
                    <button class="tab" data-tab="html">HTML Preview</button>
                </div>

                <div id="markdown-preview" class="tab-content active">
                    <div class="preview-box" id="markdownContent">No content yet. Select a PDF and click Convert.</div>
                </div>

                <div id="json-preview" class="tab-content">
                    <div class="preview-box" id="jsonContent">No content yet.</div>
                </div>

                <div id="html-preview" class="tab-content">
                    <div class="preview-box" id="htmlContent">No content yet.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Global state
        let state = {
            pdfDoc: null,
            pdfFile: null,
            extractedData: [],
            imageMapping: {},
            markdownContent: '',
            jsonContent: {},
            htmlContent: '',
            cancelFlag: false,
            imageCounter: 0
        };

        // DOM elements
        const pdfInput = document.getElementById('pdfInput');
        const fileInfo = document.getElementById('fileInfo');
        const convertBtn = document.getElementById('convertBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const markdownContent = document.getElementById('markdownContent');
        const jsonContent = document.getElementById('jsonContent');
        const htmlContent = document.getElementById('htmlContent');
        const statsSection = document.getElementById('statsSection');
        const downloadSection = document.getElementById('downloadSection');

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab + '-preview').classList.add('active');
            });
        });

        // File selection
        pdfInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                state.pdfFile = file;
                fileInfo.style.display = 'block';
                fileInfo.innerHTML = `<strong>Selected:</strong> ${file.name}<br><strong>Size:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB`;
                convertBtn.disabled = false;
                
                // Reset previous results
                state.extractedData = [];
                state.imageMapping = {};
                state.markdownContent = '';
                state.jsonContent = {};
                state.htmlContent = '';
                downloadAllBtn.disabled = true;
                downloadSection.style.display = 'none';
                statsSection.style.display = 'none';
                markdownContent.textContent = 'Ready to convert. Click "Convert PDF" button.';
                jsonContent.textContent = '';
                htmlContent.textContent = '';
            } else {
                alert('Please select a valid PDF file');
            }
        });

        // Convert button
        convertBtn.addEventListener('click', async () => {
            if (!state.pdfFile) return;
            
            state.cancelFlag = false;
            convertBtn.disabled = true;
            cancelBtn.disabled = false;
            downloadAllBtn.disabled = true;
            
            try {
                await processPDF();
                
                if (!state.cancelFlag) {
                    progressText.textContent = 'Conversion complete!';
                    downloadAllBtn.disabled = false;
                    downloadSection.style.display = 'block';
                    statsSection.style.display = 'block';
                    
                    // Update stats
                    const wordCount = state.markdownContent.split(/\s+/).length;
                    const totalSize = (new Blob([state.markdownContent]).size + 
                                     new Blob([JSON.stringify(state.jsonContent)]).size + 
                                     new Blob([state.htmlContent]).size) / 1024;
                    
                    document.getElementById('statPages').textContent = state.extractedData.length;
                    document.getElementById('statImages').textContent = Object.keys(state.imageMapping).length;
                    document.getElementById('statWords').textContent = wordCount.toLocaleString();
                    document.getElementById('statSize').textContent = totalSize.toFixed(1);
                }
            } catch (error) {
                alert('Error processing PDF: ' + error.message);
                progressText.textContent = 'Error: ' + error.message;
            } finally {
                convertBtn.disabled = false;
                cancelBtn.disabled = true;
            }
        });

        // Cancel button
        cancelBtn.addEventListener('click', () => {
            state.cancelFlag = true;
            progressText.textContent = 'Cancelling...';
            cancelBtn.disabled = true;
        });

        // Calculate base font size from document
        function calculateBaseFontSize(allPagesData) {
            const allFontSizes = [];
            allPagesData.forEach(pageData => {
                pageData.blocks.forEach(block => {
                    if (block.items) {
                        block.items.forEach(item => {
                            if (item.fontSize && item.fontSize > 0) {
                                allFontSizes.push(item.fontSize);
                            }
                        });
                    }
                });
            });
            
            if (allFontSizes.length === 0) return 12;
            
            // Sort and find median (more robust than mean)
            allFontSizes.sort((a, b) => a - b);
            const median = allFontSizes[Math.floor(allFontSizes.length / 2)];
            
            // Or use the most common size
            const counts = {};
            allFontSizes.forEach(size => {
                const rounded = Math.round(size);
                counts[rounded] = (counts[rounded] || 0) + 1;
            });
            
            let maxCount = 0;
            let baseSize = median;
            for (const [size, count] of Object.entries(counts)) {
                if (count > maxCount) {
                    maxCount = count;
                    baseSize = parseFloat(size);
                }
            }
            
            return baseSize || 12;
        }

        // Main PDF processing function
        async function processPDF() {
            const startPage = parseInt(document.getElementById('startPage').value) || 1;
            const firstPageAs = parseInt(document.getElementById('firstPageAs').value) || 1;
            
            progressText.textContent = 'Loading PDF...';
            progressFill.style.width = '0%';
            
            // Load PDF
            const arrayBuffer = await state.pdfFile.arrayBuffer();
            state.pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            const totalPages = state.pdfDoc.numPages;
            
            if (startPage > totalPages) {
                throw new Error(`Start page (${startPage}) exceeds total pages (${totalPages})`);
            }
            
            state.extractedData = [];
            state.imageMapping = {};
            state.imageCounter = 1;
            
            // Extract content page by page
            for (let pageNum = startPage; pageNum <= totalPages; pageNum++) {
                if (state.cancelFlag) {
                    progressText.textContent = 'Cancelled';
                    return;
                }
                
                const progress = ((pageNum - startPage + 1) / (totalPages - startPage + 1)) * 100;
                progressFill.style.width = progress + '%';
                progressText.textContent = `Processing page ${pageNum} of ${totalPages}...`;
                
                const page = await state.pdfDoc.getPage(pageNum);
                const pageData = await extractPageContent(page, pageNum, firstPageAs, startPage);
                state.extractedData.push(pageData);
                
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            // Calculate base font size for relative heading detection
            const baseFontSize = calculateBaseFontSize(state.extractedData);
            
            // Re-analyze blocks with base font size
            state.extractedData.forEach(pageData => {
                pageData.blocks = pageData.blocks.map(block => {
                    return reanalyzeBlockWithBaseSize(block, baseFontSize);
                });
            });
            
            // Convert to different formats
            progressText.textContent = 'Converting to HTML...';
            state.htmlContent = convertToHTML(state.extractedData);
            
            progressText.textContent = 'Converting to Markdown...';
            state.markdownContent = convertToMarkdown(state.extractedData);
            
            // Apply post-processing to markdown
            progressText.textContent = 'Post-processing Markdown...';
            state.markdownContent = postProcessMarkdown(state.markdownContent);
            
            progressText.textContent = 'Converting to JSON...';
            state.jsonContent = convertToJSON(state.extractedData);
            
            // Show previews
            showPreviews();
            
            progressFill.style.width = '100%';
        }
        
        // Re-analyze block with base font size for better heading detection
        function reanalyzeBlockWithBaseSize(block, baseFontSize) {
            if (block.type === 'heading') {
                // Use relative font size to determine heading level
                const relativeSize = block.fontSize / baseFontSize;
                
                if (relativeSize >= 1.5) {
                    block.level = 1;
                } else if (relativeSize >= 1.3) {
                    block.level = 2;
                } else if (relativeSize >= 1.1) {
                    block.level = 3;
                } else if (relativeSize >= 1.0) {
                    block.level = 4;
                } else {
                    block.level = 5;
                }
            }
            return block;
        }

        // Extract content from a single page with full formatting preservation
        async function extractPageContent(page, pageNum, firstPageAs, startPage) {
            const currentPageNum = firstPageAs + (pageNum - startPage);
            
            // Suppress PDF.js font warnings by intercepting console.warn temporarily
            const originalWarn = console.warn;
            const fontWarnings = [];
            console.warn = function(...args) {
                const message = args.join(' ');
                // Filter out font-related warnings
                if (message.includes('TT:') || message.includes('undefined function') || 
                    message.includes('Missing') || message.includes('font')) {
                    fontWarnings.push(message);
                    return; // Suppress these warnings
                }
                originalWarn.apply(console, args);
            };
            
            let textContent;
            try {
                // Get text content with options that are more tolerant of font issues
                textContent = await page.getTextContent({
                    normalizeWhitespace: false,
                    disableCombineTextItems: false
                });
            } catch (error) {
                // If getTextContent fails, try without options
                try {
                    textContent = await page.getTextContent();
                } catch (e) {
                    console.warn = originalWarn;
                    console.warn(`Error extracting text from page ${pageNum}:`, e.message);
                    return {
                        page_number: currentPageNum,
                        blocks: []
                    };
                }
            }
            
            // Restore original console.warn
            console.warn = originalWarn;
            
            const viewport = page.getViewport({ scale: 1.0 });
            
            // Collect all text items with formatting info
            const textItems = [];
            textContent.items.forEach(item => {
                try {
                    if (item.str && item.str.trim()) {
                        // Extract font information from PDF.js item with safe fallbacks
                        const fontName = (item.fontName || '').toString();
                        
                        // Calculate font size from transform matrix with robust error handling
                        // transform = [a, b, c, d, e, f]
                        // Font size is typically sqrt(a^2 + b^2) or use height if available
                        let fontSize = 12;
                        
                        try {
                            if (item.height && item.height > 0 && !isNaN(item.height)) {
                                fontSize = Math.abs(item.height);
                            } else if (item.transform && Array.isArray(item.transform) && item.transform.length >= 4) {
                                const a = parseFloat(item.transform[0]) || 0;
                                const b = parseFloat(item.transform[1]) || 0;
                                const calculated = Math.sqrt(a * a + b * b);
                                if (calculated > 0 && !isNaN(calculated) && isFinite(calculated)) {
                                    fontSize = calculated;
                                } else if (item.transform[0] && !isNaN(item.transform[0])) {
                                    fontSize = Math.abs(item.transform[0]);
                                }
                            }
                        } catch (e) {
                            // If font size calculation fails, use default
                            fontSize = 12;
                        }
                        
                        // Ensure reasonable font size
                        if (fontSize < 6 || fontSize > 72 || isNaN(fontSize) || !isFinite(fontSize)) {
                            fontSize = 12;
                        }
                        
                        // Detect bold from font name (safe string operations)
                        const isBold = fontName && (
                            /bold|black|heavy|demibold|semibold/i.test(fontName) ||
                            fontName.includes('Bold')
                        );
                        
                        // Detect italic from font name (safe string operations)
                        const isItalic = fontName && (
                            /italic|oblique/i.test(fontName) ||
                            fontName.includes('Italic')
                        );
                        
                        // Extract position from transform matrix with safe access
                        let x = 0;
                        let y = 0;
                        try {
                            if (item.transform && Array.isArray(item.transform) && item.transform.length >= 6) {
                                x = parseFloat(item.transform[4]) || 0;
                                y = parseFloat(item.transform[5]) || 0;
                            }
                        } catch (e) {
                            // Use defaults if transform parsing fails
                        }
                        
                        textItems.push({
                            text: item.str,
                            x: x,
                            y: y,
                            fontSize: fontSize,
                            isBold: isBold || false,
                            isItalic: isItalic || false,
                            width: (item.width && !isNaN(item.width)) ? item.width : 0,
                            fontName: fontName
                        });
                    }
                } catch (error) {
                    // Skip items that cause errors, but continue processing
                    console.warn(`Error processing text item on page ${pageNum}:`, error.message);
                }
            });
            
            // Group items into lines based on Y position
            const lines = [];
            const yTolerance = 2; // pixels
            
            textItems.forEach(item => {
                if (!item || typeof item.y !== 'number') {
                    return; // Skip invalid items
                }
                
                let foundLine = false;
                for (let line of lines) {
                    if (line && typeof line.y === 'number' && Math.abs(line.y - item.y) < yTolerance) {
                        if (!line.items) {
                            line.items = [];
                        }
                        if (Array.isArray(line.items)) {
                            line.items.push(item);
                        }
                        foundLine = true;
                        break;
                    }
                }
                if (!foundLine) {
                    lines.push({
                        y: item.y,
                        items: [item],
                        x: item.x || 0
                    });
                }
            });
            
            // Sort lines by Y position (top to bottom)
            lines.sort((a, b) => {
                const ay = (a && typeof a.y === 'number') ? a.y : 0;
                const by = (b && typeof b.y === 'number') ? b.y : 0;
                return by - ay;
            });
            
            // Group lines into blocks based on spacing and analyze structure
            const blocks = [];
            let currentBlock = { items: [], lines: [], fontSizes: [], xPositions: [] };
            let prevY = null;
            
            lines.forEach((line, idx) => {
                // Ensure line.items exists and is an array
                if (!line || !line.items || !Array.isArray(line.items) || line.items.length === 0) {
                    return;
                }
                
                const lineText = line.items.map(i => i && i.text ? i.text : '').join('').trim();
                if (!lineText) return;
                
                // Ensure currentBlock has all required arrays
                if (!currentBlock.items) currentBlock.items = [];
                if (!currentBlock.lines) currentBlock.lines = [];
                if (!currentBlock.fontSizes) currentBlock.fontSizes = [];
                if (!currentBlock.xPositions) currentBlock.xPositions = [];
                
                const avgFontSize = line.items.reduce((sum, i) => sum + (i && i.fontSize ? i.fontSize : 12), 0) / line.items.length;
                const hasBold = line.items.some(i => i && i.isBold);
                const lineIndentItems = line.items.filter(i => i && typeof i.x === 'number').map(i => i.x);
                const lineIndent = lineIndentItems.length > 0 ? Math.min(...lineIndentItems) : 0;
                
                // Calculate vertical spacing
                const spacing = prevY !== null && typeof line.y === 'number' ? Math.abs(prevY - line.y) : 0;
                const isLargeSpacing = spacing > avgFontSize * 1.5;
                
                // Determine if this should start a new block
                if (currentBlock.items && currentBlock.items.length > 0 && (isLargeSpacing || shouldStartNewBlock(line, currentBlock))) {
                    if (currentBlock.items.length > 0) {
                        const analyzedBlock = analyzeBlock(currentBlock);
                        if (analyzedBlock) {
                            blocks.push(analyzedBlock);
                        }
                    }
                    currentBlock = { items: [], lines: [], fontSizes: [], xPositions: [] };
                }
                
                // Safely push items
                if (Array.isArray(line.items)) {
                    currentBlock.items.push(...line.items.filter(i => i != null));
                }
                if (line) {
                    currentBlock.lines.push(line);
                }
                if (!isNaN(avgFontSize) && isFinite(avgFontSize)) {
                    currentBlock.fontSizes.push(avgFontSize);
                }
                if (!isNaN(lineIndent) && isFinite(lineIndent)) {
                    currentBlock.xPositions.push(lineIndent);
                }
                
                if (typeof line.y === 'number') {
                    prevY = line.y;
                }
            });
            
            // Add last block
            if (currentBlock && currentBlock.items && currentBlock.items.length > 0) {
                const analyzedBlock = analyzeBlock(currentBlock);
                if (analyzedBlock) {
                    blocks.push(analyzedBlock);
                }
            }
            
            return {
                page_number: currentPageNum,
                blocks: blocks
            };
        }
        
        // Determine if a new block should start
        function shouldStartNewBlock(line, currentBlock) {
            if (!line || !line.items || !Array.isArray(line.items) || line.items.length === 0) {
                return false;
            }
            
            if (!currentBlock) {
                return true;
            }
            
            const lineText = line.items.map(i => i && i.text ? i.text : '').join('').trim();
            const avgFontSize = line.items.reduce((sum, i) => sum + (i && i.fontSize ? i.fontSize : 12), 0) / line.items.length;
            
            const blockAvgFontSize = (currentBlock.fontSizes && Array.isArray(currentBlock.fontSizes) && currentBlock.fontSizes.length > 0)
                ? currentBlock.fontSizes.reduce((a, b) => (a || 0) + (b || 0), 0) / currentBlock.fontSizes.length 
                : 12;
            
            // If line has significantly larger font, likely a heading
            if (avgFontSize > blockAvgFontSize * 1.3) {
                return true;
            }
            
            // If line is centered or has different indentation pattern
            const lineIndentItems = line.items.filter(i => i && typeof i.x === 'number').map(i => i.x);
            const lineIndent = lineIndentItems.length > 0 ? Math.min(...lineIndentItems) : 0;
            
            const blockAvgIndent = (currentBlock.xPositions && Array.isArray(currentBlock.xPositions) && currentBlock.xPositions.length > 0)
                ? currentBlock.xPositions.reduce((a, b) => (a || 0) + (b || 0), 0) / currentBlock.xPositions.length
                : 0;
            
            if (Math.abs(lineIndent - blockAvgIndent) > 50) {
                return true;
            }
            
            return false;
        }
        
        // Analyze block to determine type and properties
        function analyzeBlock(block) {
            if (!block) {
                return null;
            }
            
            // Ensure all required properties exist
            if (!block.items || !Array.isArray(block.items) || block.items.length === 0) {
                return null;
            }
            
            if (!block.fontSizes || !Array.isArray(block.fontSizes)) {
                block.fontSizes = [];
            }
            
            if (!block.lines || !Array.isArray(block.lines)) {
                block.lines = [];
            }
            
            const allText = block.items.map(i => i && i.text ? i.text : '').join(' ').trim();
            if (!allText) {
                return null;
            }
            
            const avgFontSize = block.fontSizes.length > 0
                ? block.fontSizes.reduce((a, b) => (a || 0) + (b || 0), 0) / block.fontSizes.length
                : 12;
            const maxFontSize = block.fontSizes.length > 0 ? Math.max(...block.fontSizes.filter(s => s && !isNaN(s))) : 12;
            const minFontSize = block.fontSizes.length > 0 ? Math.min(...block.fontSizes.filter(s => s && !isNaN(s))) : 12;
            const hasBold = block.items.some(i => i && i.isBold);
            const hasItalic = block.items.some(i => i && i.isItalic);
            const lineCount = block.lines.length;
            const textLength = allText.length;
            
            // Detect list patterns
            const firstLine = block.lines[0];
            if (firstLine && firstLine.items && Array.isArray(firstLine.items) && firstLine.items.length > 0) {
                const firstItem = firstLine.items[0];
                if (firstItem && firstItem.text) {
                    const firstText = firstItem.text.trim();
                    
                    // Numbered list (1., 2., etc.)
                    if (/^[\d]+[\.\)]\s/.test(firstText)) {
                        return {
                            type: 'ordered_list',
                            text: allText,
                            items: block.items,
                            level: determineIndentLevel(block)
                        };
                    }
                    
                    // Bullet list (-, *, ‚Ä¢, etc.)
                    if (/^[-*‚Ä¢‚ñ™‚ñ´‚óã]\s/.test(firstText)) {
                        return {
                            type: 'unordered_list',
                            text: allText,
                            items: block.items,
                            level: determineIndentLevel(block)
                        };
                    }
                }
            }
            
            // Determine heading level based on font size
            let headingLevel = null;
            if (lineCount === 1 && textLength < 200) {
                // Potential heading - analyze font size
                if (maxFontSize >= 18) {
                    headingLevel = 1;
                } else if (maxFontSize >= 16) {
                    headingLevel = 2;
                } else if (maxFontSize >= 14 && (hasBold || textLength < 80)) {
                    headingLevel = 3;
                } else if (maxFontSize >= 13 && hasBold && textLength < 100) {
                    headingLevel = 4;
                } else if (hasBold && textLength < 120 && avgFontSize > 12) {
                    headingLevel = 5;
                }
            }
            
            if (headingLevel) {
                return {
                    type: 'heading',
                    level: headingLevel,
                    text: allText,
                    items: block.items,
                    fontSize: maxFontSize
                };
            }
            
            // Regular paragraph
            return {
                type: 'paragraph',
                text: allText,
                items: block.items,
                fontSize: avgFontSize
            };
        }
        
        // Determine indentation level for lists
        function determineIndentLevel(block) {
            if (!block || !block.xPositions || !Array.isArray(block.xPositions) || block.xPositions.length === 0) {
                return 0;
            }
            const validPositions = block.xPositions.filter(p => p != null && !isNaN(p) && isFinite(p));
            if (validPositions.length === 0) return 0;
            const avgIndent = validPositions.reduce((a, b) => (a || 0) + (b || 0), 0) / validPositions.length;
            // Convert pixel indent to level (rough estimate: 20px per level)
            return Math.max(0, Math.floor(avgIndent / 20));
        }

        // Convert to HTML with formatting preservation
        function convertToHTML(data) {
            let html = '<!DOCTYPE html>\n<html>\n<head>\n<meta charset="utf-8">\n<title>PDF Content</title>\n</head>\n<body>\n\n';
            
            data.forEach(pageData => {
                html += `<div class="page" data-page="${pageData.page_number}">\n`;
                
                pageData.blocks.forEach(block => {
                    switch (block.type) {
                        case 'heading':
                            const level = block.level || 2;
                            const headingHtml = formatInlineHtml(block.items);
                            html += `  <h${level}>${headingHtml}</h${level}>\n`;
                            break;
                            
                        case 'ordered_list':
                            const olHtml = formatInlineHtml(block.items);
                            html += `  <ol>\n    <li>${olHtml}</li>\n  </ol>\n`;
                            break;
                            
                        case 'unordered_list':
                            const ulHtml = formatInlineHtml(block.items);
                            html += `  <ul>\n    <li>${ulHtml}</li>\n  </ul>\n`;
                            break;
                            
                        case 'paragraph':
                        default:
                            const paraHtml = formatInlineHtml(block.items);
                            html += `  <p>${paraHtml}</p>\n`;
                            break;
                    }
                });
                
                html += '</div>\n\n';
            });
            
            html += '</body>\n</html>';
            return html;
        }
        
        // Format inline HTML with bold and italic tags
        function formatInlineHtml(items) {
            if (!items || items.length === 0) return '';
            
            let result = '';
            let currentRun = { text: '', isBold: false, isItalic: false };
            
            items.forEach((item, idx) => {
                const text = item.text || '';
                const isBold = item.isBold || false;
                const isItalic = item.isItalic || false;
                
                if (idx > 0 && (currentRun.isBold !== isBold || currentRun.isItalic !== isItalic)) {
                    result += formatHtmlRun(currentRun);
                    currentRun = { text: '', isBold: isBold, isItalic: isItalic };
                } else if (idx === 0) {
                    currentRun.isBold = isBold;
                    currentRun.isItalic = isItalic;
                }
                
                currentRun.text += text;
            });
            
            result += formatHtmlRun(currentRun);
            return result.trim();
        }
        
        // Format HTML run with tags
        function formatHtmlRun(run) {
            if (!run.text.trim()) return '';
            
            let text = escapeHtml(run.text);
            
            if (run.isBold && run.isItalic) {
                return `<strong><em>${text}</em></strong>`;
            } else if (run.isBold) {
                return `<strong>${text}</strong>`;
            } else if (run.isItalic) {
                return `<em>${text}</em>`;
            }
            
            return text;
        }

        // Convert to Markdown with full formatting preservation
        function convertToMarkdown(data) {
            const filename = state.pdfFile.name.replace('.pdf', '');
            let markdown = '---\n';
            markdown += `title: "${escapeYaml(filename)}"\n`;
            markdown += 'aliases:\n';
            markdown += `  - "${escapeYaml(filename)}"\n`;
            markdown += 'types:\n';
            markdown += '  - "[[TYPE - Document]]"\n';
            markdown += '  - "[[TYPE - PDF]]"\n';
            markdown += '---\n\n';
            markdown += `# ${filename}\n\n`;
            
            let prevBlockType = null;
            
            data.forEach(pageData => {
                pageData.blocks.forEach((block, idx) => {
                    switch (block.type) {
                        case 'heading':
                            const level = block.level || 2;
                            const headingText = formatInlineText(block.items);
                            markdown += `${'#'.repeat(level)} ${headingText}\n\n`;
                            break;
                            
                        case 'ordered_list':
                            const olIndent = '  '.repeat(block.level || 0);
                            const olText = formatInlineText(block.items);
                            // Extract number if present
                            const match = olText.match(/^(\d+[\.\)]\s*)(.+)$/);
                            if (match) {
                                markdown += `${olIndent}${match[1]}${match[2]}\n`;
                            } else {
                                markdown += `${olIndent}1. ${olText}\n`;
                            }
                            break;
                            
                        case 'unordered_list':
                            const ulIndent = '  '.repeat(block.level || 0);
                            const ulText = formatInlineText(block.items);
                            // Remove existing bullet if present
                            const cleanUlText = ulText.replace(/^[-*‚Ä¢‚ñ™‚ñ´‚óã]\s*/, '');
                            markdown += `${ulIndent}- ${cleanUlText}\n`;
                            break;
                            
                        case 'paragraph':
                        default:
                            const paraText = formatInlineText(block.items);
                            if (paraText.trim()) {
                                markdown += `${paraText}\n\n`;
                            }
                            break;
                    }
                    
                    prevBlockType = block.type;
                });
            });
            
            // Clean up excessive newlines
            markdown = markdown.replace(/\n{3,}/g, '\n\n');
            
            return markdown.trim();
        }
        
        // Format inline text with bold and italic preservation
        function formatInlineText(items) {
            if (!items || items.length === 0) return '';
            
            let result = '';
            let currentRun = { text: '', isBold: false, isItalic: false };
            
            items.forEach((item, idx) => {
                const text = item.text || '';
                const isBold = item.isBold || false;
                const isItalic = item.isItalic || false;
                
                // Check if formatting changed
                if (idx > 0 && (currentRun.isBold !== isBold || currentRun.isItalic !== isItalic)) {
                    // Close previous run
                    result += formatRun(currentRun);
                    currentRun = { text: '', isBold: isBold, isItalic: isItalic };
                } else if (idx === 0) {
                    currentRun.isBold = isBold;
                    currentRun.isItalic = isItalic;
                }
                
                currentRun.text += text;
            });
            
            // Close last run
            result += formatRun(currentRun);
            
            return result.trim();
        }
        
        // Format a text run with markdown formatting
        function formatRun(run) {
            if (!run.text.trim()) return '';
            
            let text = run.text;
            
            // Apply formatting
            if (run.isBold && run.isItalic) {
                return `***${text}***`;
            } else if (run.isBold) {
                return `**${text}**`;
            } else if (run.isItalic) {
                return `*${text}*`;
            }
            
            return text;
        }
        
        // Escape YAML special characters
        function escapeYaml(text) {
            if (typeof text !== 'string') return text;
            return text.replace(/"/g, '\\"').replace(/\n/g, '\\n');
        }
        
        // Post-process markdown text with various cleanup rules
        function postProcessMarkdown(text) {
            if (!text || typeof text !== 'string') return text;
            
            const enablePostProcessing = document.getElementById('enablePostProcessing').checked;
            if (!enablePostProcessing) return text;
            
            let processed = text;
            
            // 1. Remove character strings (from textarea, one per line)
            const removeStringsText = document.getElementById('removeStrings').value;
            if (removeStringsText.trim()) {
                const stringsToRemove = removeStringsText.split('\n').filter(s => s.trim());
                stringsToRemove.forEach(str => {
                    if (str.trim()) {
                        // Escape regex special characters
                        const escapedStr = str.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(escapedStr, 'g');
                        processed = processed.replace(regex, '');
                    }
                });
            }
            
            // 2. Add space between different character scripts (Latin/CJK)
            if (document.getElementById('addSpaceBetweenScripts').checked) {
                // CJK Unicode ranges: Chinese, Japanese, Korean
                // \u4E00-\u9FFF: CJK Unified Ideographs
                // \u3040-\u309F: Hiragana
                // \u30A0-\u30FF: Katakana
                // \uAC00-\uD7AF: Hangul
                
                // Add space between CJK and Latin (CJK -> Latin)
                processed = processed.replace(/([\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF])([a-zA-Z])/g, '$1 $2');
                
                // Add space between Latin and CJK (Latin -> CJK)
                processed = processed.replace(/([a-zA-Z])([\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF])/g, '$1 $2');
                
                // Add space between CJK and numbers
                processed = processed.replace(/([\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF])(\d)/g, '$1 $2');
                processed = processed.replace(/(\d)([\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF])/g, '$1 $2');
            }
            
            // 3. Add space around punctuation
            if (document.getElementById('addSpaceAroundPunctuation').checked) {
                // Add space after punctuation if not followed by space or newline
                // Common punctuation: . , ! ? ; :
                processed = processed.replace(/([.,:;!?])([^\s\n.,!?;:\]\)\}])/g, '$1 $2');
                
                // Add space before punctuation if preceded by alphanumeric without space
                // This handles cases like "word.Next" -> "word. Next"
                // But preserve common abbreviations and decimals
                processed = processed.replace(/([a-zA-Z\u4E00-\u9FFF])\.([A-Z])/g, '$1. $2');
            }
            
            // 4. Add space before capitalized letter if preceded by lowercase
            if (document.getElementById('addSpaceBeforeCapital').checked) {
                // Vietnamese diacritics: √†-·ªπ, √Ä-·ª∏ (extended Latin)
                // Add space between lowercase (including Vietnamese) and uppercase
                // But avoid breaking acronyms or intentional camelCase
                processed = processed.replace(/([a-z\u00E0-\u00FC\u1EA0-\u1EF9])([A-Z\u00C0-\u00DC\u1EA0-\u1EF9])/g, '$1 $2');
                
                // Handle special cases with CJK followed by uppercase Latin
                processed = processed.replace(/([\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF])([A-Z])/g, '$1 $2');
            }
            
            // Clean up multiple spaces (but preserve intentional double spaces for line breaks)
            processed = processed.replace(/([^\s\n]) {3,}/g, '$1 ');
            
            // Clean up space before newlines (but preserve double space for markdown line breaks)
            processed = processed.replace(/(?<!  ) +\n/g, '\n');
            
            // Protect markdown syntax from unwanted spaces
            // Preserve **bold**, *italic*, [[links]], ==highlights==, etc.
            processed = processed.replace(/\*\* +/g, '**');
            processed = processed.replace(/ +\*\*/g, '**');
            
            // Be more careful with single asterisks (could be list markers)
            processed = processed.replace(/\* +([^\s])/g, '* $1'); // List item
            processed = processed.replace(/([^\s*]) +\*/g, '$1*'); // End italic
            processed = processed.replace(/\*([^\s*]) +/g, '*$1 '); // Start italic
            
            // Protect wikilinks
            processed = processed.replace(/\[\[ +/g, '[[');
            processed = processed.replace(/ +\]\]/g, ']]');
            
            // Protect highlights
            processed = processed.replace(/== +/g, '==');
            processed = processed.replace(/ +==/g, '==');
            
            // Protect code
            processed = processed.replace(/` +/g, '`');
            processed = processed.replace(/ +`/g, '`');
            
            // Protect markdown headers (don't add space after #)
            processed = processed.replace(/^(#{1,6}) +(?=[^\s])/gm, '$1 ');
            
            // Fix spacing in YAML frontmatter (don't add spaces around colons)
            processed = processed.replace(/^(\s*[a-zA-Z_]+)\s*:\s+/gm, '$1: ');
            
            return processed;
        }

        // Convert to JSON
        function convertToJSON(data) {
            return {
                metadata: {
                    filename: state.pdfFile.name,
                    total_pages: data.length,
                    processed_date: new Date().toISOString()
                },
                pages: data.map(page => ({
                    page: page.page_number,
                    blocks: page.blocks.map(block => ({
                        text: block.text,
                        type: block.type
                    }))
                }))
            };
        }

        // Show previews in tabs
        function showPreviews() {
            // Markdown preview (truncated)
            const mdLines = state.markdownContent.split('\n');
            if (mdLines.length > 200) {
                markdownContent.textContent = mdLines.slice(0, 100).join('\n') + 
                    '\n\n... [Content truncated for preview - download full file] ...\n\n' +
                    mdLines.slice(-100).join('\n');
            } else {
                markdownContent.textContent = state.markdownContent;
            }
            
            // JSON preview
            jsonContent.textContent = JSON.stringify(state.jsonContent, null, 2);
            
            // HTML preview (truncated)
            const htmlLines = state.htmlContent.split('\n');
            if (htmlLines.length > 200) {
                htmlContent.textContent = htmlLines.slice(0, 100).join('\n') + 
                    '\n\n... [Content truncated for preview - download full file] ...\n\n' +
                    htmlLines.slice(-100).join('\n');
            } else {
                htmlContent.textContent = state.htmlContent;
            }
        }

        // Generate timestamp in [yymmddhhmm] format
        function getTimestamp() {
            const now = new Date();
            const yy = String(now.getFullYear()).slice(-2);
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            return `[${yy}${mm}${dd}${hh}${min}]`;
        }

        // Download functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Individual download buttons
        document.getElementById('downloadMdBtn').addEventListener('click', () => {
            const timestamp = getTimestamp();
            const filename = state.pdfFile.name.replace('.pdf', '');
            downloadFile(state.markdownContent, `${timestamp} - ${filename}.md`, 'text/markdown');
        });

        document.getElementById('downloadJsonBtn').addEventListener('click', () => {
            const timestamp = getTimestamp();
            const filename = state.pdfFile.name.replace('.pdf', '');
            downloadFile(JSON.stringify(state.jsonContent, null, 2), `${timestamp} - ${filename}.json`, 'application/json');
        });

        document.getElementById('downloadHtmlBtn').addEventListener('click', () => {
            const timestamp = getTimestamp();
            const filename = state.pdfFile.name.replace('.pdf', '');
            downloadFile(state.htmlContent, `${timestamp} - ${filename}.html`, 'text/html');
        });

        document.getElementById('downloadSummaryBtn').addEventListener('click', () => {
            const timestamp = getTimestamp();
            const filename = state.pdfFile.name.replace('.pdf', '');
            const summary = {
                timestamp: timestamp,
                script_name: '241104_PDF_To_Obsidian_Markdown_And_JSON_Converter.html',
                input_file: state.pdfFile.name,
                output_description: 'PDF To Obsidian Markdown And JSON Converter',
                statistics: {
                    total_pages: state.extractedData.length,
                    total_images: Object.keys(state.imageMapping).length,
                    word_count: state.markdownContent.split(/\s+/).length,
                    markdown_size_kb: (new Blob([state.markdownContent]).size / 1024).toFixed(2),
                    json_size_kb: (new Blob([JSON.stringify(state.jsonContent)]).size / 1024).toFixed(2)
                }
            };
            downloadFile(JSON.stringify(summary, null, 2), `${timestamp} - summary.json`, 'application/json');
        });

        // Download all button
        downloadAllBtn.addEventListener('click', () => {
            const timestamp = getTimestamp();
            const filename = state.pdfFile.name.replace('.pdf', '');
            
            // Download all files with small delays
            setTimeout(() => downloadFile(state.markdownContent, `${timestamp} - ${filename}.md`, 'text/markdown'), 0);
            setTimeout(() => downloadFile(JSON.stringify(state.jsonContent, null, 2), `${timestamp} - ${filename}.json`, 'application/json'), 500);
            setTimeout(() => downloadFile(state.htmlContent, `${timestamp} - ${filename}.html`, 'text/html'), 1000);
            
            const summary = {
                timestamp: timestamp,
                script_name: '241104_PDF_To_Obsidian_Markdown_And_JSON_Converter.html',
                input_file: state.pdfFile.name,
                output_description: 'PDF To Obsidian Markdown And JSON Converter',
                statistics: {
                    total_pages: state.extractedData.length,
                    word_count: state.markdownContent.split(/\s+/).length,
                    markdown_size_kb: (new Blob([state.markdownContent]).size / 1024).toFixed(2)
                }
            };
            setTimeout(() => downloadFile(JSON.stringify(summary, null, 2), `${timestamp} - summary.json`, 'application/json'), 1500);
            
            alert(`All files will download shortly with timestamp: ${timestamp}`);
        });

        // Utility function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>

