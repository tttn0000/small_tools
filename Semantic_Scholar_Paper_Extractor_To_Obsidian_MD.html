<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Scholar Paper Extractor to Obsidian MD</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .section {
            margin-bottom: 20px;
        }
        
        .section-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #555;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #333;
        }
        
        .log-area {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f9f9f9;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        button.primary {
            background-color: #007bff;
            color: white;
        }
        
        button.primary:hover:not(:disabled) {
            background-color: #0056b3;
        }
        
        button.secondary {
            background-color: #6c757d;
            color: white;
        }
        
        button.secondary:hover:not(:disabled) {
            background-color: #545b62;
        }
        
        button.danger {
            background-color: #dc3545;
            color: white;
        }
        
        button.danger:hover:not(:disabled) {
            background-color: #c82333;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .progress-fill {
            height: 100%;
            background: #007bff;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        
        .description {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #004085;
            line-height: 1.6;
        }
        
        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 13px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Semantic Scholar Paper Extractor to Obsidian MD</h1>
        
        <div class="description">
            <strong>Description:</strong> Extract paper information from Semantic Scholar API and generate Obsidian-formatted Markdown files with complete metadata, citations, and references.
            <br><br>
            <strong>Accepted Formats:</strong> Semantic Scholar Paper ID, Semantic Scholar URL, DOI number, DOI URL, arXiv ID/URL, PMID, PMCID, or CorpusId (one per line).
        </div>
        
        <div class="section">
            <div class="section-title">Input Papers (One per line)</div>
            <textarea id="inputText" placeholder="Enter paper information here (one per line)...&#10;&#10;Examples:&#10;- Semantic Scholar ID: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0&#10;- S2 URL: https://www.semanticscholar.org/paper/Title/a1b2c3d4...&#10;- DOI: 10.1234/example.doi.12345&#10;- DOI URL: https://doi.org/10.1234/example.doi.12345&#10;- arXiv: 2301.12345 or https://arxiv.org/abs/2301.12345"></textarea>
        </div>
        
        <div class="section">
            <div class="section-title">Statistics</div>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Total Inputs</div>
                    <div class="stat-value" id="totalInputs">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Legitimate Inputs</div>
                    <div class="stat-value" id="legitimateInputs">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Illegitimate Inputs</div>
                    <div class="stat-value" id="illegitimateInputs">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">MD Files Created</div>
                    <div class="stat-value" id="mdFilesCreated">0</div>
                </div>
            </div>
        </div>
        
        <div class="button-group">
            <button class="primary" id="extractBtn">Create MD for Papers</button>
            <button class="danger" id="cancelBtn" disabled>Cancel</button>
            <button class="secondary" id="clearLogBtn">Clear Log</button>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
        </div>
        
        <div class="info-box" id="infoBox"></div>
        
        <div class="section">
            <div class="section-title">Processing Log</div>
            <div class="log-area" id="logArea"></div>
        </div>
    </div>

    <script>
// --------------------ARGS
const ARGS = {
    API_BASE_URL: "https://api.semanticscholar.org/graph/v1",
    PAPER_FIELDS: "paperId,externalIds,url,title,abstract,year,fieldsOfStudy,s2FieldsOfStudy,publicationTypes,authors,citationStyles,citations,references",
    REFERENCE_FIELDS: "paperId,title,year",
    CITATION_FIELDS: "paperId,title,year",
    TN_ID_TOTAL_MAX: 35,
    TITLE_PADDING_CHAR: "-",
    TITLE_REPLACE_CHAR: "_",
    MAX_RETRIES: 5,
    BASE_DELAY: 6000,
    MIN_RETRY_DELAY: 15000,
    MAX_DELAY: 32000,
    BATCH_SIZE: 500,
    OUTPUT_DESCRIPTION: "Semantic Scholar Paper Extractor To Obsidian MD"
};

// --------------------CONSTANTS & CONFIGURATIONS
let cancelExtraction = false;
let stats = {
    totalInputs: 0,
    legitimateInputs: 0,
    illegitimateInputs: 0,
    successfulApiCalls: 0,
    failedApiCalls: 0,
    mdFilesCreated: 0
};

let processedPapers = {};
let citationPapers = {};
let referencePapers = {};
let illegitimateInputs = [];
let allLogMessages = [];
let apiRequestTimes = [];

// --------------------GUI COMPONENTS
const inputText = document.getElementById('inputText');
const extractBtn = document.getElementById('extractBtn');
const cancelBtn = document.getElementById('cancelBtn');
const clearLogBtn = document.getElementById('clearLogBtn');
const logArea = document.getElementById('logArea');
const progressFill = document.getElementById('progressFill');
const infoBox = document.getElementById('infoBox');

// Statistics display elements
const totalInputsEl = document.getElementById('totalInputs');
const legitimateInputsEl = document.getElementById('legitimateInputs');
const illegitimateInputsEl = document.getElementById('illegitimateInputs');
const mdFilesCreatedEl = document.getElementById('mdFilesCreated');

// --------------------MAIN APPLICATION
let auditTimer = null;

inputText.addEventListener('input', () => {
    if (auditTimer) clearTimeout(auditTimer);
    auditTimer = setTimeout(auditInputStatistics, 800);
});

extractBtn.addEventListener('click', startExtraction);
cancelBtn.addEventListener('click', () => {
    cancelExtraction = true;
    log('Cancellation requested. Terminating operations...', 'WARNING');
    cancelBtn.disabled = true;
});
clearLogBtn.addEventListener('click', () => {
    logArea.textContent = '';
    allLogMessages = [];
});

function log(message, level = 'INFO') {
    const timestamp = new Date().toLocaleTimeString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    allLogMessages.push({ timestamp, level, message });
    logArea.textContent += logMessage + '\n';
    logArea.scrollTop = logArea.scrollHeight;
}

function updateStatistics() {
    totalInputsEl.textContent = stats.totalInputs;
    legitimateInputsEl.textContent = stats.legitimateInputs;
    illegitimateInputsEl.textContent = stats.illegitimateInputs;
    mdFilesCreatedEl.textContent = stats.mdFilesCreated;
}

function updateProgress(percent) {
    percent = Math.min(100, Math.max(0, percent));
    progressFill.style.width = percent + '%';
    progressFill.textContent = Math.round(percent) + '%';
}

function extractPaperId(text) {
    text = text.trim();
    
    // Semantic Scholar URL
    const s2Match = text.match(/semanticscholar\.org\/paper\/(?:[^/]+\/)?([a-f0-9]{40})/);
    if (s2Match) return s2Match[1];
    
    // DOI URL
    const doiUrlMatch = text.match(/doi\.org\/(10\.\d+\/[^\s]+)/);
    if (doiUrlMatch) return `DOI:${doiUrlMatch[1]}`;
    
    // Direct Semantic Scholar ID (40 char hex)
    if (/^[a-f0-9]{40}$/.test(text)) return text;
    
    // Direct DOI
    const doiMatch = text.match(/^(10\.\d+\/[^\s]+)$/);
    if (doiMatch) return `DOI:${doiMatch[1]}`;
    
    // arXiv URL
    const arxivMatch = text.match(/arxiv\.org\/(?:abs|pdf)\/(\d+\.\d+)/);
    if (arxivMatch) return `ARXIV:${arxivMatch[1]}`;
    
    // Direct arXiv ID
    const arxivIdMatch = text.match(/^(?:arXiv:|ARXIV:)?(\d+\.\d+)$/);
    if (arxivIdMatch) return `ARXIV:${arxivIdMatch[1]}`;
    
    // PMID
    const pmidMatch = text.match(/^(?:PMID:)?(\d{7,})$/);
    if (pmidMatch) return `PMID:${pmidMatch[1]}`;
    
    // CorpusId
    const corpusMatch = text.match(/^(?:CorpusId:)?(\d+)$/);
    if (corpusMatch) return `CorpusId:${corpusMatch[1]}`;
    
    return null;
}

function auditInputStatistics() {
    const inputValue = inputText.value.trim();
    stats.totalInputs = 0;
    stats.legitimateInputs = 0;
    stats.illegitimateInputs = 0;
    
    if (inputValue) {
        const lines = inputValue.split('\n').filter(line => line.trim());
        stats.totalInputs = lines.length;
        
        lines.forEach(line => {
            if (extractPaperId(line)) {
                stats.legitimateInputs++;
            } else {
                stats.illegitimateInputs++;
            }
        });
        
        if (stats.totalInputs > 0) {
            log(`Input audit: ${stats.legitimateInputs} legitimate and ${stats.illegitimateInputs} illegitimate inputs`, 'INFO');
        }
    }
    
    updateStatistics();
}

function normalizeTitle(title) {
    if (!title) return "unknown_title";
    
    title = title.toLowerCase();
    title = title.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
    title = title.replace(/[^a-z0-9]+/g, ARGS.TITLE_REPLACE_CHAR);
    title = title.replace(/^_+|_+$/g, '');
    title = title.replace(/_+/g, ARGS.TITLE_REPLACE_CHAR);
    
    return title;
}

function padTitle(title, targetLength) {
    if (title.length > targetLength) return title.substring(0, targetLength);
    return title + ARGS.TITLE_PADDING_CHAR.repeat(targetLength - title.length);
}

function generateTNLibraryId(year, title) {
    let yearStr = "0000";
    if (year) {
        yearStr = String(year).padStart(4, '0');
    }
    
    const normalizedTitle = normalizeTitle(title);
    const titleMax = ARGS.TN_ID_TOTAL_MAX - (yearStr.length + 1);
    const paddedTitle = padTitle(normalizedTitle, Math.max(1, titleMax));
    
    return `${yearStr}-${paddedTitle}`;
}

function formatPublicationType(pubType) {
    if (!pubType) return pubType;
    return pubType.replace(/(?<!^)(?=[A-Z])/g, ' ');
}

function cleanTextBlock(text) {
    if (!text) return text;
    
    // Convert to string if not already
    text = String(text);
    
    // Replace multiple consecutive whitespace characters (spaces, tabs, newlines) with a single space
    text = text.replace(/[\s\n\r\t]+/g, ' ');
    
    // Trim leading and trailing whitespace
    text = text.trim();
    
    return text;
}

async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function makeApiRequest(endpoint, params = {}, method = "GET", jsonData = null) {
    const url = new URL(`${ARGS.API_BASE_URL}/${endpoint}`);
    
    if (method === "GET") {
        Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
    }
    
    for (let retry = 0; retry < ARGS.MAX_RETRIES; retry++) {
        if (cancelExtraction) return null;
        
        try {
            await sleep(ARGS.BASE_DELAY);
            
            if (retry > 0) {
                const delay = Math.max(ARGS.MIN_RETRY_DELAY, ARGS.MIN_RETRY_DELAY * Math.pow(2, retry - 1));
                log(`Retry ${retry}/${ARGS.MAX_RETRIES} after ${(delay/1000).toFixed(1)}s delay`, 'WARNING');
                await sleep(delay);
            }
            
            const options = {
                method: method,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                }
            };
            
            if (method === "POST" && jsonData) {
                options.body = JSON.stringify(jsonData);
                if (params && Object.keys(params).length > 0) {
                    Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
                }
            }
            
            const response = await fetch(url.toString(), options);
            
            if (response.status === 200) {
                return await response.json();
            } else if (response.status === 429) {
                const retryAfter = response.headers.get('retry-after');
                const waitTime = retryAfter ? parseInt(retryAfter) * 1000 + 2000 : ARGS.MIN_RETRY_DELAY;
                log(`Rate limit exceeded. Waiting ${(waitTime/1000).toFixed(1)}s`, 'WARNING');
                await sleep(waitTime);
                continue;
            } else if (response.status === 404) {
                log(`Resource not found: ${endpoint}`, 'ERROR');
                return null;
            } else if (response.status >= 500) {
                log(`Server error ${response.status}. Retrying...`, 'ERROR');
                continue;
            } else {
                const errorText = await response.text();
                log(`API error: ${response.status} - ${errorText.substring(0, 200)}`, 'ERROR');
                return null;
            }
        } catch (error) {
            log(`Request failed: ${error.message}`, 'ERROR');
            if (retry === ARGS.MAX_RETRIES - 1) return null;
            continue;
        }
    }
    
    log(`Failed to get data after ${ARGS.MAX_RETRIES} retries`, 'ERROR');
    return null;
}

async function batchFetchPaperData(paperIds, fields) {
    if (!paperIds || paperIds.length === 0) return {};
    
    const results = {};
    const paperIdsList = Array.from(paperIds);
    const totalIds = paperIdsList.length;
    
    log(`Batch fetching data for ${totalIds} papers`, 'INFO');
    
    const batchSize = Math.min(ARGS.BATCH_SIZE, totalIds);
    const numBatches = Math.ceil(totalIds / batchSize);
    
    for (let batchIdx = 0; batchIdx < numBatches; batchIdx++) {
        if (cancelExtraction) break;
        
        const startIdx = batchIdx * batchSize;
        const endIdx = Math.min(startIdx + batchSize, totalIds);
        const currentBatch = paperIdsList.slice(startIdx, endIdx);
        
        log(`Processing batch ${batchIdx + 1}/${numBatches} with ${currentBatch.length} papers`, 'INFO');
        
        try {
            const batchParams = { fields: fields };
            const batchData = { ids: currentBatch };
            
            const batchResponse = await makeApiRequest("paper/batch", batchParams, "POST", batchData);
            
            if (!batchResponse) {
                log(`No response from API for batch ${batchIdx + 1}`, 'ERROR');
                continue;
            }
            
            let responseData = [];
            if (Array.isArray(batchResponse)) {
                responseData = batchResponse;
            } else if (batchResponse.data && Array.isArray(batchResponse.data)) {
                responseData = batchResponse.data;
            }
            
            let validPapers = 0;
            responseData.forEach(paper => {
                if (cancelExtraction) return;
                if (!paper || !paper.paperId) return;
                
                results[paper.paperId] = paper;
                validPapers++;
            });
            
            log(`Batch ${batchIdx + 1} results: Retrieved ${responseData.length} papers, ${validPapers} valid`, 'INFO');
            
        } catch (error) {
            log(`Error processing batch ${batchIdx + 1}: ${error.message}`, 'ERROR');
        }
        
        if (batchIdx < numBatches - 1 && !cancelExtraction) {
            await sleep(500);
        }
    }
    
    log(`Batch fetching complete. Retrieved ${Object.keys(results).length} papers total.`, 'INFO');
    return results;
}

function processPaperData(paperData, referenceIdsToFetch, citationIdsToFetch) {
    if (!paperData) return null;
    
    const tnlibraryId = generateTNLibraryId(paperData.year, paperData.title || "");
    
    const externalIds = paperData.externalIds || {};
    
    const fieldsOfStudy = new Set();
    if (Array.isArray(paperData.fieldsOfStudy)) {
        paperData.fieldsOfStudy.forEach(field => fieldsOfStudy.add(field));
    }
    if (Array.isArray(paperData.s2FieldsOfStudy)) {
        paperData.s2FieldsOfStudy.forEach(field => {
            if (field && field.category) fieldsOfStudy.add(field.category);
        });
    }
    
    const authors = [];
    if (Array.isArray(paperData.authors)) {
        paperData.authors.forEach(author => {
            if (author && author.name) {
                const authorId = author.authorId || "unknown";
                authors.push(`${author.name} - ${authorId}`);
            }
        });
    }
    
    const citations = [];
    if (Array.isArray(paperData.citations)) {
        paperData.citations.forEach(citation => {
            if (citation && citation.paperId && citation.title) {
                const paperId = citation.paperId;
                if (paperId && !citation.year && !citationPapers[paperId]) {
                    citationIdsToFetch.add(paperId);
                }
                
                const citationYear = citation.year || 0;
                const citationTitle = cleanTextBlock(citation.title);
                const citationTnlibraryId = generateTNLibraryId(citationYear, citationTitle);
                citations.push({
                    ID_S2: citation.paperId,
                    tn_library_id: citationTnlibraryId,
                    title: citationTitle,
                    year: citationYear
                });
            }
        });
    }
    
    const references = [];
    if (Array.isArray(paperData.references)) {
        paperData.references.forEach(reference => {
            if (reference && reference.paperId && reference.title) {
                const paperId = reference.paperId;
                if (paperId && !reference.year && !referencePapers[paperId]) {
                    referenceIdsToFetch.add(paperId);
                }
                
                const referenceYear = reference.year || 0;
                const referenceTitle = cleanTextBlock(reference.title);
                const referenceTnlibraryId = generateTNLibraryId(referenceYear, referenceTitle);
                references.push({
                    ID_S2: reference.paperId,
                    tn_library_id: referenceTnlibraryId,
                    title: referenceTitle,
                    year: referenceYear
                });
            }
        });
    }
    
    let bibtex = "";
    const citationStyles = paperData.citationStyles || {};
    if (citationStyles.bibtex) {
        bibtex = cleanTextBlock(citationStyles.bibtex);
    }
    
    const pubTypes = paperData.publicationTypes || [];
    
    return {
        tn_library_id: tnlibraryId,
        ID_S2: paperData.paperId,
        ID_DOI: externalIds.DOI,
        ID_CorpusId: externalIds.CorpusId,
        url_S2: paperData.url,
        title: cleanTextBlock(paperData.title),
        abstract: paperData.abstract ? cleanTextBlock(paperData.abstract) : null,
        year: paperData.year,
        fields_of_study: Array.from(fieldsOfStudy).sort(),
        authors: authors,
        publication_types: pubTypes,
        bibtex: bibtex,
        citations: citations,
        references: references
    };
}

function updateReferencesAndCitations(papers) {
    if (cancelExtraction) return papers;
    
    log(`Updating references and citations with fetched year data for ${Object.keys(papers).length} papers`, 'INFO');
    
    Object.keys(papers).forEach(paperId => {
        if (cancelExtraction) return;
        
        const paper = papers[paperId];
        
        paper.references.forEach((ref, i) => {
            const refId = ref.ID_S2;
            if (referencePapers[refId] && referencePapers[refId].year) {
                if (ref.year === 0) {
                    papers[paperId].references[i].year = referencePapers[refId].year;
                    const newTnlibraryId = generateTNLibraryId(referencePapers[refId].year, ref.title);
                    papers[paperId].references[i].tn_library_id = newTnlibraryId;
                }
            }
        });
        
        paper.citations.forEach((cit, i) => {
            const citId = cit.ID_S2;
            if (citationPapers[citId] && citationPapers[citId].year) {
                if (cit.year === 0) {
                    papers[paperId].citations[i].year = citationPapers[citId].year;
                    const newTnlibraryId = generateTNLibraryId(citationPapers[citId].year, cit.title);
                    papers[paperId].citations[i].tn_library_id = newTnlibraryId;
                }
            }
        });
    });
    
    return papers;
}

function generateMarkdownContent(paperData) {
    if (!paperData) return null;
    
    const tnlibraryId = paperData.tn_library_id;
    if (!tnlibraryId) return null;
    
    let md = "---\n";
    
    // Title
    const title = cleanTextBlock(paperData.title) || "Unknown Title";
    md += `title: "${title.replace(/"/g, '\\"')}"\n`;
    
    // Abstract
    if (paperData.abstract) {
        const cleanedAbstract = cleanTextBlock(paperData.abstract);
        md += `abstract: "${cleanedAbstract.replace(/"/g, '\\"')}"\n`;
    }
    
    // Aliases
    const aliases = [];
    const shortTitle = title.split(/[:\.\?\!]/)[0].trim();
    aliases.push(shortTitle);
    
    if (paperData.year && paperData.authors && paperData.authors.length > 0) {
        const firstAuthor = paperData.authors[0].split(' - ')[0];
        const lastName = firstAuthor.split(' ').pop();
        aliases.push(`${lastName}, ${paperData.year}`);
    }
    
    md += "aliases:\n";
    aliases.forEach(alias => {
        md += `- ${alias}\n`;
    });
    
    // Types
    md += "types:\n";
    md += `- "[[TYPE - Publication]]"\n`;
    if (paperData.publication_types && paperData.publication_types.length > 0) {
        paperData.publication_types.forEach(pubType => {
            const formatted = formatPublicationType(pubType);
            md += `- "[[TYPE - ${formatted}]]"\n`;
        });
    }
    
    // Year
    if (paperData.year) {
        md += `year_publication: "[[y-${paperData.year}]]"\n`;
    }
    
    // Topics
    if (paperData.fields_of_study && paperData.fields_of_study.length > 0) {
        md += "topics:\n";
        paperData.fields_of_study.forEach(field => {
            md += `- "[[FIELD - ${field}]]"\n`;
        });
    }
    
    // Parent
    md += "parent:\n";
    
    // Authors
    if (paperData.authors && paperData.authors.length > 0) {
        md += "authors:\n";
        paperData.authors.forEach(author => {
            const authorName = author.split(' - ')[0];
            md += `- "[[${authorName}]]"\n`;
        });
    }
    
    // URLs
    if (paperData.ID_DOI) {
        md += `url_DOI: "https://doi.org/${paperData.ID_DOI}"\n`;
    }
    if (paperData.url_S2) {
        md += `url_S2: "${paperData.url_S2}"\n`;
    }
    
    // BibTeX
    if (paperData.bibtex) {
        const cleanedBibtex = cleanTextBlock(paperData.bibtex);
        md += `bibtex: "${cleanedBibtex.replace(/"/g, '\\"')}"\n`;
    }
    
    md += "---\n\n";
    
    // Title heading
    md += `# ${title}\n\n`;
    
    // Full Text
    md += "# Full Text\n";
    md += `![[${tnlibraryId}.pdf]]\n\n`;
    
    // References and Citations
    md += "# References and Citations\n\n";
    
    // References
    md += "## References\n";
    if (paperData.references && paperData.references.length > 0) {
        paperData.references.forEach(ref => {
            const refIdTn = ref.tn_library_id || "unknown";
            const refTitle = ref.title || "Unknown Title";
            const refIdS2 = ref.ID_S2 || "unknown";
            md += `- [[${refIdTn}|${refTitle}]] (S2iD: ${refIdS2})\n`;
        });
    } else {
        md += "No references found.\n";
    }
    
    md += "\n";
    
    // Citations
    md += "## Citations\n";
    if (paperData.citations && paperData.citations.length > 0) {
        paperData.citations.forEach(cit => {
            const citIdTn = cit.tn_library_id || "unknown";
            const citTitle = cit.title || "Unknown Title";
            const citIdS2 = cit.ID_S2 || "unknown";
            md += `- [[${citIdTn}|CITATION - ${citTitle}]] (S2iD: ${citIdS2})\n`;
        });
    } else {
        md += "No citations found.\n";
    }
    
    return { filename: `${tnlibraryId}.md`, content: md };
}

async function startExtraction() {
    const inputValue = inputText.value.trim();
    if (!inputValue) {
        alert('Please enter at least one paper ID or URL.');
        return;
    }
    
    extractBtn.disabled = true;
    cancelBtn.disabled = false;
    updateProgress(0);
    
    cancelExtraction = false;
    processedPapers = {};
    citationPapers = {};
    referencePapers = {};
    illegitimateInputs = [];
    stats.legitimateInputs = 0;
    stats.illegitimateInputs = 0;
    stats.successfulApiCalls = 0;
    stats.failedApiCalls = 0;
    stats.mdFilesCreated = 0;
    
    const lines = inputValue.split('\n').filter(line => line.trim());
    stats.totalInputs = lines.length;
    updateStatistics();
    
    log(`Starting extraction for ${stats.totalInputs} input(s)`, 'INFO');
    
    // Request output folder at the start
    const timestamp = new Date();
    const timestampStr = formatTimestamp(timestamp);
    log('Please select the output folder where files will be saved...', 'INFO');
    const outputFolderHandle = await selectOutputFolder(timestampStr);
    
    if (!outputFolderHandle && 'showDirectoryPicker' in window) {
        log('Output folder selection cancelled. Extraction aborted.', 'WARNING');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    if (!outputFolderHandle) {
        infoBox.style.display = 'block';
        infoBox.textContent = 'File System Access API not available. Files will be downloaded individually. Please save each file to the same folder.';
    }
    
    // Parse and validate inputs
    const legitimateInputItems = [];
    lines.forEach(line => {
        if (cancelExtraction) return;
        
        const paperId = extractPaperId(line);
        if (paperId) {
            stats.legitimateInputs++;
            let idType = "other";
            if (paperId.startsWith("DOI:")) {
                idType = "doi";
            } else if (/^[a-f0-9]{40}$/.test(paperId)) {
                idType = "s2_id";
            }
            legitimateInputItems.push({
                type: idType,
                id: paperId,
                original_text: line
            });
        } else {
            stats.illegitimateInputs++;
            illegitimateInputs.push(line);
            log(`Invalid input format: ${line}`, 'ERROR');
        }
    });
    
    updateStatistics();
    
    if (legitimateInputItems.length === 0) {
        log('No legitimate inputs found', 'ERROR');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    // Batch fetch all papers
    log(`Batch fetching data for ${legitimateInputItems.length} legitimate inputs`, 'INFO');
    
    const paperIds = legitimateInputItems.map(item => item.id);
    const paperResults = await batchFetchPaperData(paperIds, ARGS.PAPER_FIELDS);
    
    if (cancelExtraction) {
        log('Extraction cancelled by user', 'WARNING');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    if (Object.keys(paperResults).length === 0) {
        log('Failed to fetch any paper data', 'ERROR');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    log(`Successfully fetched data for ${Object.keys(paperResults).length} papers`, 'SUCCESS');
    stats.successfulApiCalls = Object.keys(paperResults).length;
    stats.failedApiCalls = legitimateInputItems.length - Object.keys(paperResults).length;
    updateStatistics();
    
    // Process papers
    const referenceIdsToFetch = new Set();
    const citationIdsToFetch = new Set();
    const allPaperData = [];
    
    let processCount = 0;
    const totalToProcess = Object.keys(paperResults).length;
    
    for (const [paperId, paperData] of Object.entries(paperResults)) {
        if (cancelExtraction) break;
        
        processCount++;
        log(`Processing paper ${processCount}/${totalToProcess}: ${paperData.title || 'Unknown Title'}`, 'INFO');
        
        const processedData = processPaperData(paperData, referenceIdsToFetch, citationIdsToFetch);
        
        if (processedData) {
            const processedPaperId = processedData.ID_S2;
            if (processedPaperId) {
                processedPapers[processedPaperId] = processedData;
                allPaperData.push(processedData);
            }
        }
        
        updateProgress((processCount / totalToProcess) * 50);
    }
    
    if (cancelExtraction) {
        log('Extraction cancelled by user', 'WARNING');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    // Batch fetch references
    if (referenceIdsToFetch.size > 0) {
        log(`Batch fetching data for ${referenceIdsToFetch.size} unique references`, 'INFO');
        const referenceResults = await batchFetchPaperData(referenceIdsToFetch, ARGS.REFERENCE_FIELDS);
        Object.assign(referencePapers, referenceResults);
        log(`Fetched and cached data for ${Object.keys(referenceResults).length} references`, 'SUCCESS');
        updateProgress(65);
    }
    
    if (cancelExtraction) {
        log('Extraction cancelled by user', 'WARNING');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    // Batch fetch citations
    if (citationIdsToFetch.size > 0) {
        log(`Batch fetching data for ${citationIdsToFetch.size} unique citations`, 'INFO');
        const citationResults = await batchFetchPaperData(citationIdsToFetch, ARGS.CITATION_FIELDS);
        Object.assign(citationPapers, citationResults);
        log(`Fetched and cached data for ${Object.keys(citationResults).length} citations`, 'SUCCESS');
        updateProgress(80);
    }
    
    if (cancelExtraction) {
        log('Extraction cancelled by user', 'WARNING');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    // Update papers with reference and citation data
    log('Updating all papers with fetched reference and citation data', 'INFO');
    processedPapers = updateReferencesAndCitations(processedPapers);
    
    // Generate markdown files
    log(`Generating markdown files for ${Object.keys(processedPapers).length} papers`, 'INFO');
    
    const markdownFiles = [];
    let mdCount = 0;
    const totalPapers = Object.keys(processedPapers).length;
    
    for (const [paperId, paperData] of Object.entries(processedPapers)) {
        if (cancelExtraction) break;
        
        const mdFile = generateMarkdownContent(paperData);
        if (mdFile) {
            markdownFiles.push(mdFile);
            stats.mdFilesCreated++;
            log(`Created markdown file: ${mdFile.filename}`, 'SUCCESS');
        }
        
        mdCount++;
        updateProgress(80 + ((mdCount / totalPapers) * 15));
    }
    
    updateStatistics();
    
    if (cancelExtraction) {
        log('Extraction cancelled by user', 'WARNING');
        extractBtn.disabled = false;
        cancelBtn.disabled = true;
        return;
    }
    
    // Generate report
    const reportFilename = `[${timestampStr}] - Report.txt`;
    
    let reportContent = "=".repeat(80) + "\n";
    reportContent += "SEMANTIC SCHOLAR PAPER EXTRACTION REPORT\n";
    reportContent += `Generated: ${timestamp.toLocaleString()}\n`;
    reportContent += "=".repeat(80) + "\n\n";
    reportContent += "-".repeat(80) + "\n";
    reportContent += "STATISTICS\n";
    reportContent += "-".repeat(80) + "\n";
    reportContent += `Total inputs: ${stats.totalInputs}\n`;
    reportContent += `Legitimate inputs: ${stats.legitimateInputs}\n`;
    reportContent += `Illegitimate inputs: ${stats.illegitimateInputs}\n`;
    reportContent += `Successful API calls: ${stats.successfulApiCalls}\n`;
    reportContent += `Failed API calls: ${stats.failedApiCalls}\n`;
    reportContent += `MD files created: ${stats.mdFilesCreated}\n\n`;
    reportContent += "-".repeat(80) + "\n";
    reportContent += "LOG MESSAGES\n";
    reportContent += "-".repeat(80) + "\n";
    allLogMessages.forEach(msg => {
        reportContent += `[${msg.timestamp}] [${msg.level}] ${msg.message}\n`;
    });
    
    markdownFiles.push({ filename: reportFilename, content: reportContent });
    
    // Generate summary JSON
    const summaryData = {
        timestamp: timestamp.toISOString(),
        output_description: ARGS.OUTPUT_DESCRIPTION,
        input_source: "User Input",
        statistics: stats,
        processed_papers: Object.values(processedPapers),
        illegitimate_inputs: illegitimateInputs
    };
    
    const summaryFilename = `[${timestampStr}] - Summary.json`;
    markdownFiles.push({ 
        filename: summaryFilename, 
        content: JSON.stringify(summaryData, null, 2) 
    });
    
    updateProgress(95);
    
    // Save files
    await saveFiles(markdownFiles, timestampStr, outputFolderHandle);
    
    updateProgress(100);
    log('Extraction process complete', 'SUCCESS');
    log(`Successfully processed ${stats.successfulApiCalls} of ${stats.totalInputs} input(s)`, 'INFO');
    log(`Created ${stats.mdFilesCreated} markdown files`, 'INFO');
    
    extractBtn.disabled = false;
    cancelBtn.disabled = true;
}

function formatTimestamp(date) {
    const year = String(date.getFullYear()).substring(2);
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}${month}${day}${hours}${minutes}`;
}

async function selectOutputFolder(timestampStr) {
    const folderName = `[${timestampStr}] - ${ARGS.OUTPUT_DESCRIPTION}`;
    
    // Try File System Access API first
    if ('showDirectoryPicker' in window) {
        try {
            const dirHandle = await window.showDirectoryPicker({
                mode: 'readwrite',
                startIn: 'documents'
            });
            
            // Create run folder
            const runFolderHandle = await dirHandle.getDirectoryHandle(folderName, { create: true });
            
            log(`Selected output folder: ${folderName}`, 'INFO');
            return runFolderHandle;
            
        } catch (error) {
            if (error.name === 'AbortError') {
                log('User cancelled folder selection', 'WARNING');
                return null;
            } else {
                log(`Error using File System Access API: ${error.message}`, 'ERROR');
                return null;
            }
        }
    } else {
        log('File System Access API not available. Will use individual downloads.', 'WARNING');
        return null;
    }
}

async function saveFiles(files, timestampStr, outputFolderHandle) {
    const folderName = `[${timestampStr}] - ${ARGS.OUTPUT_DESCRIPTION}`;
    
    if (outputFolderHandle) {
        // Save all files to the selected folder
        log(`Saving files to output folder: ${folderName}`, 'INFO');
        
        for (const file of files) {
            if (cancelExtraction) break;
            
            const fileHandle = await outputFolderHandle.getFileHandle(file.filename, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(file.content);
            await writable.close();
            
            log(`Saved file: ${file.filename}`, 'SUCCESS');
        }
        
        log('All files saved successfully', 'SUCCESS');
    } else {
        // Fallback to download
        downloadFilesIndividually(files, folderName);
    }
}

function downloadFilesIndividually(files, folderName) {
    infoBox.style.display = 'block';
    infoBox.innerHTML = `<strong>IMPORTANT:</strong> Please create a folder named:<br><code>${folderName}</code><br>and save all ${files.length} files into it.`;
    
    log(`Downloading ${files.length} files individually`, 'INFO');
    
    files.forEach((file, index) => {
        setTimeout(() => {
            if (cancelExtraction) return;
            
            const blob = new Blob([file.content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = file.filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log(`Downloaded file: ${file.filename}`, 'SUCCESS');
        }, index * 300);
    });
}

// Initialize
auditInputStatistics();
    </script>
</body>
</html>

