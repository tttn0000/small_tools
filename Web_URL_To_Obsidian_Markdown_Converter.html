<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web URL to Obsidian Markdown Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            padding: 40px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
            text-align: center;
        }

        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="text"], input[type="url"] {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus, input[type="url"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-group {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: 500;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4b5563;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(107, 114, 128, 0.4);
        }

        .status-area {
            margin-top: 30px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 8px;
            min-height: 100px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .status-area.active {
            display: block;
        }

        .status-line {
            padding: 6px 0;
            font-size: 14px;
            color: #555;
            font-family: 'Courier New', monospace;
        }

        .status-line.success {
            color: #10b981;
            font-weight: 600;
        }

        .status-line.error {
            color: #ef4444;
            font-weight: 600;
        }

        .status-line.info {
            color: #3b82f6;
        }

        .status-line.warning {
            color: #f59e0b;
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 20px;
            overflow: hidden;
            display: none;
        }

        .progress-bar.active {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .info-box {
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 16px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #1e40af;
        }

        .info-box strong {
            display: block;
            margin-bottom: 8px;
        }

        .info-box ul {
            margin-left: 20px;
            margin-top: 8px;
        }

        .info-box li {
            margin: 4px 0;
        }

        .info-box code,
        .cors-warning code {
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .cors-warning {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 16px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #92400e;
        }

        .cors-warning p {
            margin: 8px 0;
        }

        .cors-warning ul {
            margin: 8px 0 0 20px;
            padding-left: 20px;
        }

        .cors-warning li {
            margin: 4px 0;
        }

        textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
            resize: vertical;
            min-height: 200px;
            max-height: 500px;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .html-input-container {
            display: none;
        }

        .html-input-container.active {
            display: block;
        }

        .url-input-container {
            display: block;
        }

        .url-input-container.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê Web to Obsidian Converter</h1>
        <p class="subtitle">Fetch web articles and convert to Obsidian Markdown</p>

        <div class="cors-warning" id="corsWarning">
            <strong>‚ö†Ô∏è Important: CORS Limitation</strong>
            <p>When opening this file directly (file://), browsers block cross-origin requests for security. Even CORS proxies may be blocked.</p>
            <p><strong>Solution:</strong> Run a local web server:</p>
            <ul>
                <li><strong>Python:</strong> <code>python -m http.server 8000</code> then open <code>http://localhost:8000/Web_URL_To_Obsidian_Markdown_Converter.html</code></li>
                <li><strong>Node.js:</strong> <code>npx http-server</code> then open the displayed URL</li>
                <li><strong>VS Code:</strong> Use "Live Server" extension</li>
                <li><strong>Quick Start:</strong> Double-click <code>Start_Local_Server.bat</code> in this folder</li>
            </ul>
            <p>Alternatively, some CORS proxies may work - the tool will try multiple options automatically.</p>
        </div>

        <div class="info-box">
            <strong>‚ÑπÔ∏è How to use:</strong>
            <ul>
                <li><strong>URL Mode:</strong> Enter the full URL of the article (e.g., https://example.com/article)</li>
                <li><strong>HTML Mode:</strong> Enable "Paste HTML source code" and paste the HTML source directly</li>
                <li>Enable "Use CORS Proxy" for websites that block direct access (URL mode only)</li>
                <li>Click "Convert & Download" to process</li>
                <li>Select a folder to save the output files (Markdown, images, and summary)</li>
                <li>Use "Download Again" button to re-download the last processed article without re-processing</li>
            </ul>
        </div>

        <form id="converterForm">
            <div class="checkbox-group">
                <input type="checkbox" id="useHtmlMode">
                <label for="useHtmlMode">Paste HTML source code instead of URL</label>
            </div>

            <div class="input-group url-input-container" id="urlInputContainer">
                <label for="urlInput">Article URL:</label>
                <input 
                    type="url" 
                    id="urlInput" 
                    placeholder="https://www.example.com/article/..." 
                >
            </div>

            <div class="input-group html-input-container" id="htmlInputContainer">
                <label for="htmlInput">HTML Source Code:</label>
                <textarea 
                    id="htmlInput" 
                    placeholder="Paste your HTML source code here..."
                    rows="10"
                ></textarea>
            </div>

            <div class="input-group">
                <label for="prefixInput">Markdown Filename Prefix (optional):</label>
                <input 
                    type="text" 
                    id="prefixInput" 
                    placeholder="ARTICLE - " 
                    value="ARTICLE - "
                >
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="downloadImages" checked>
                <label for="downloadImages">Download images</label>
            </div>

            <div class="checkbox-group" id="corsProxyContainer">
                <input type="checkbox" id="useCorsProxy">
                <label for="useCorsProxy">Use CORS Proxy (for blocked sites)</label>
            </div>

            <div class="button-group">
                <button type="submit" class="btn-primary" id="convertBtn">
                    Convert & Download
                </button>
                <button type="button" class="btn-secondary" id="downloadAgainBtn" style="display: none;">
                    Download Again
                </button>
            </div>
        </form>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="status-area" id="statusArea"></div>
    </div>

    <script>
        // --------------------CONSTANTS & CONFIGURATIONS
        const CORS_PROXIES = [
            'https://api.allorigins.win/get?url=',
            'https://api.allorigins.win/raw?url=',
            'https://cors-anywhere.herokuapp.com/',
            'https://thingproxy.freeboard.io/fetch/',
            'https://corsproxy.org/?',
            'https://api.codetabs.com/v1/proxy?quest='
        ];
        const IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.bmp', '.webp'];
        const TIMESTAMP_FORMAT = 'yymmddhhmm';
        
        // Detect if running from file:// protocol
        const isLocalFile = window.location.protocol === 'file:';
        
        const ARTICLE_SELECTORS = [
            'section.ArticleContent',
            'article.ArticlePageWrapper',
            'div.article-content',
            'main.article',
            'article',
            'main',
            // Interactive/news site selectors
            '[data-module="ArticleBody"]',
            '[data-module="StoryBody"]',
            '.story-body',
            '.article-body',
            '.content-body',
            '.entry-content',
            '.post-content',
            '.article-text',
            '.story-text',
            '.article-main',
            '.story-main',
            '[role="article"]',
            '.interactive-content',
            '.interactive-body',
            '#main-content',
            '#article-content',
            '#story-content',
            '.container article',
            '.content article',
            'main [role="main"]',
            // SMH specific
            '.story-body__inner',
            '.story-body__content',
            '.interactive-story',
            '.interactive-content-wrapper'
        ];

        const HEADER_SELECTORS = [
            'section.ArticleHeader',
            'header.article-header',
            'div.article-header',
            'header',
            // Additional header selectors
            '.article-header',
            '.story-header',
            '.entry-header',
            '.post-header',
            'header[role="banner"]',
            '.article-meta',
            '.story-meta'
        ];

        // --------------------UTILITY FUNCTIONS

        function getTimestamp() {
            const now = new Date();
            const yy = String(now.getFullYear()).slice(-2);
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            return `${yy}${mm}${dd}${hh}${min}`;
        }

        function sanitizeFilename(filename) {
            const invalid = /[<>:"/\\|?*]/g;
            return filename.replace(invalid, '_').replace(/\s+/g, '_').replace(/_+/g, '_').trim();
        }

        function normalizeTitle(title, maxLength = 50, prefix = "ARTICLE - ") {
            const invalid = /[<>:"/\\|?*]/g;
            title = title.replace(invalid, '').replace(/\s+/g, ' ').trim();
            
            const availableLength = maxLength - prefix.length;
            if (title.length > availableLength) {
                title = title.substring(0, availableLength).trim();
                const lastSpace = title.lastIndexOf(' ');
                if (lastSpace > availableLength * 0.7) {
                    title = title.substring(0, lastSpace);
                }
            }
            
            return prefix + title;
        }

        function addStatus(message, type = 'info') {
            const statusArea = document.getElementById('statusArea');
            statusArea.classList.add('active');
            
            const line = document.createElement('div');
            line.className = `status-line ${type}`;
            
            if (type === 'info' && message.startsWith('Processing')) {
                line.innerHTML = `<span class="spinner"></span>${message}`;
            } else {
                const icon = {
                    'success': '‚úì',
                    'error': '‚úó',
                    'warning': '‚ö†',
                    'info': '‚Üí'
                }[type] || '‚Ä¢';
                line.textContent = `${icon} ${message}`;
            }
            
            statusArea.appendChild(line);
            statusArea.scrollTop = statusArea.scrollHeight;
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            progressBar.classList.add('active');
            progressFill.style.width = `${percent}%`;
        }

        function clearStatus() {
            const statusArea = document.getElementById('statusArea');
            statusArea.innerHTML = '';
            statusArea.classList.remove('active');
            
            const progressBar = document.getElementById('progressBar');
            progressBar.classList.remove('active');
            document.getElementById('progressFill').style.width = '0%';
        }

        // --------------------HTML TO MARKDOWN CONVERSION

        function extractFigureTitle(caption) {
            if (!caption) return "Figure";
            
            let title = caption.replace(/\[([^\]]+)\]\([^\)]+\)/g, '');
            title = title.replace(/<[^>]+>/g, '');
            title = title.replace(/[A-Z][a-z]+\s+Images?\/(Getty|Reuters|Shutterstock|AP)/g, '');
            title = title.split('.')[0];
            
            if (title.length > 60) {
                title = title.substring(0, 57) + '...';
            }
            
            return title.trim() || "Figure";
        }

        function cleanCaption(caption) {
            if (!caption) return "";
            
            // Remove HTML tags but preserve content
            caption = caption.replace(/<[^>]+>/g, '');
            // Remove extra whitespace
            caption = caption.replace(/\s+/g, ' ');
            caption = caption.trim();
            
            // Pattern: Author Name/Organization Images/Stock Agency
            let creditPattern = /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\/(Getty|SOPA|Reuters|Shutterstock|AP|Alamy|iStock|Photo|Science\s+Photo\s+Library)\s+Images?\/(Getty|Reuters|Shutterstock|AP|Alamy|iStock)$/;
            let match = caption.match(creditPattern);
            
            // Also check for simple name/organization pattern without "Images/Stock" suffix
            if (!match) {
                creditPattern = /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\/(Science\s+Photo\s+Library|Getty|SOPA|Reuters|Shutterstock|AP|Alamy|iStock)$/;
                match = caption.match(creditPattern);
            }
            
            if (match) {
                const credit = match[0];
                const title = caption.substring(0, match.index).trim();
                // Format as inline footnote
                if (title) {
                    return `${title} ^[${credit}]`;
                } else {
                    // No title, just credit
                    return `^[${credit}]`;
                }
            } else {
                // Try to find image credit at the end (separate from title by space)
                // Pattern: title text credit (credit pattern: Name/Organization Images/Stock)
                // Look for credit pattern with multiple slashes
                creditPattern = /(\w+\/\w+(?:\s+Images?)?\/\w+)$/;
                match = caption.match(creditPattern);
                if (match) {
                    const credit = match[1];
                    // Remove the credit from caption
                    caption = caption.substring(0, match.index).trim();
                    // Format as inline footnote
                    if (caption) {
                        return `${caption} ^[${credit}]`;
                    } else {
                        return `^[${credit}]`;
                    }
                }
            }
            
            return caption;
        }

        function parseDateToISO(dateString) {
            if (!dateString) return '';
            
            dateString = dateString.trim();
            
            // Try to parse common date formats
            const dateFormats = [
                { pattern: /(\d{1,2})\s+(\w+)\s+(\d{4})/, parser: (match) => {
                    const months = ['january', 'february', 'march', 'april', 'may', 'june', 
                                   'july', 'august', 'september', 'october', 'november', 'december'];
                    const monthName = match[2].toLowerCase();
                    const monthIndex = months.findIndex(m => m.startsWith(monthName));
                    if (monthIndex >= 0) {
                        const day = parseInt(match[1]);
                        const year = parseInt(match[3]);
                        return new Date(year, monthIndex, day);
                    }
                    return null;
                }},
                // Already ISO format
                { pattern: /(\d{4})-(\d{2})-(\d{2})/, parser: (match) => {
                    return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                }},
                // DD/MM/YYYY or MM/DD/YYYY
                { pattern: /(\d{1,2})\/(\d{1,2})\/(\d{4})/, parser: (match) => {
                    const d1 = parseInt(match[1]);
                    const d2 = parseInt(match[2]);
                    const year = parseInt(match[3]);
                    // Try DD/MM/YYYY first
                    if (d1 <= 31 && d2 <= 12) {
                        return new Date(year, d2 - 1, d1);
                    }
                    // Otherwise MM/DD/YYYY
                    if (d1 <= 12 && d2 <= 31) {
                        return new Date(year, d1 - 1, d2);
                    }
                    return null;
                }}
            ];
            
            for (const fmt of dateFormats) {
                const match = dateString.match(fmt.pattern);
                if (match) {
                    const date = fmt.parser(match);
                    if (date && !isNaN(date.getTime())) {
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                }
            }
            
            // Fallback: try regex pattern matching
            const regexMatch = dateString.match(/(\d{1,2})\s+(\w+)\s+(\d{4})/);
            if (regexMatch) {
                const datePart = regexMatch[0].trim();
                const months = ['january', 'february', 'march', 'april', 'may', 'june', 
                               'july', 'august', 'september', 'october', 'november', 'december'];
                const monthName = regexMatch[2].toLowerCase();
                const monthIndex = months.findIndex(m => m.startsWith(monthName));
                if (monthIndex >= 0) {
                    try {
                        const day = parseInt(regexMatch[1]);
                        const year = parseInt(regexMatch[3]);
                        const date = new Date(year, monthIndex, day);
                        if (!isNaN(date.getTime())) {
                            const year = date.getFullYear();
                            const month = String(date.getMonth() + 1).padStart(2, '0');
                            const day = String(date.getDate()).padStart(2, '0');
                            return `${year}-${month}-${day}`;
                        }
                    } catch (e) {
                        // Continue
                    }
                }
            }
            
            // Return empty string if parsing completely fails
            return '';
        }

        function extractMetadata(doc, url) {
            const metadata = {
                title: '',
                authors: [],
                publication_date: '',
                category: '',
                description: '',
                url: url,
                topics: []
            };

            // Try to find header section
            let header = null;
            for (const selector of HEADER_SELECTORS) {
                header = doc.querySelector(selector);
                if (header) break;
            }

            if (header) {
                const titleElem = header.querySelector('h1.ArticleHeader__Heading, h1');
                if (titleElem) metadata.title = titleElem.textContent.trim();

                const authorElem = header.querySelector('.ArticleHeader__Author, .author, [rel="author"]');
                if (authorElem) {
                    let authorText = authorElem.textContent.trim().replace(/^By\s+/i, '');
                    if (authorText.includes(' and ')) {
                        metadata.authors = authorText.split(' and ').map(a => a.trim());
                    } else if (authorText.includes(',')) {
                        metadata.authors = authorText.split(',').map(a => a.trim());
                    } else {
                        metadata.authors = [authorText];
                    }
                }

                const dateElem = header.querySelector('.ArticleHeader__Date, .date, time, [datetime]');
                if (dateElem) {
                    const rawDate = dateElem.getAttribute('datetime') || dateElem.textContent.trim();
                    metadata.publication_date = parseDateToISO(rawDate);
                }

                const categoryElem = header.querySelector('.ArticleHeader__Category, .category');
                if (categoryElem) metadata.category = categoryElem.textContent.trim();

                const descElem = header.querySelector('.ArticleHeader__Copy, .description, .excerpt');
                if (descElem) metadata.description = descElem.textContent.trim();
            }

            // Try to extract from JSON-LD structured data
            if (!metadata.title || !metadata.description) {
                const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
                for (const script of jsonLdScripts) {
                    try {
                        const jsonData = JSON.parse(script.textContent);
                        if (Array.isArray(jsonData)) {
                            for (const item of jsonData) {
                                if (item['@type'] === 'NewsArticle' || item['@type'] === 'Article') {
                                    if (!metadata.title && item.headline) {
                                        metadata.title = item.headline;
                                    }
                                    if (!metadata.description && item.description) {
                                        metadata.description = item.description;
                                    }
                                    if (!metadata.publication_date && item.datePublished) {
                                        metadata.publication_date = parseDateToISO(item.datePublished);
                                    }
                                    if (metadata.authors.length === 0 && item.author) {
                                        if (Array.isArray(item.author)) {
                                            metadata.authors = item.author.map(a => a.name || a);
                                        } else {
                                            metadata.authors = [item.author.name || item.author];
                                        }
                                    }
                                    if (metadata.topics.length === 0 && item.keywords) {
                                        metadata.topics = Array.isArray(item.keywords) ? item.keywords : [item.keywords];
                                    }
                                    break;
                                }
                            }
                        } else if (jsonData['@type'] === 'NewsArticle' || jsonData['@type'] === 'Article') {
                            if (!metadata.title && jsonData.headline) {
                                metadata.title = jsonData.headline;
                            }
                            if (!metadata.description && jsonData.description) {
                                metadata.description = jsonData.description;
                            }
                            if (!metadata.publication_date && jsonData.datePublished) {
                                metadata.publication_date = parseDateToISO(jsonData.datePublished);
                            }
                            if (metadata.authors.length === 0 && jsonData.author) {
                                if (Array.isArray(jsonData.author)) {
                                    metadata.authors = jsonData.author.map(a => a.name || a);
                                } else {
                                    metadata.authors = [jsonData.author.name || jsonData.author];
                                }
                            }
                            if (metadata.topics.length === 0 && jsonData.keywords) {
                                metadata.topics = Array.isArray(jsonData.keywords) ? jsonData.keywords : [jsonData.keywords];
                            }
                        }
                    } catch (e) {
                        // Skip invalid JSON
                    }
                }
            }

            // Try Open Graph meta tags
            if (!metadata.title) {
                const ogTitle = doc.querySelector('meta[property="og:title"]');
                if (ogTitle) metadata.title = ogTitle.getAttribute('content');
            }
            if (!metadata.description) {
                const ogDesc = doc.querySelector('meta[property="og:description"]');
                if (ogDesc) metadata.description = ogDesc.getAttribute('content');
            }
            if (!metadata.publication_date) {
                const ogDate = doc.querySelector('meta[property="article:published_time"]');
                if (ogDate) metadata.publication_date = parseDateToISO(ogDate.getAttribute('content'));
            }
            if (metadata.authors.length === 0) {
                const ogAuthor = doc.querySelector('meta[property="article:author"]');
                if (ogAuthor) metadata.authors = [ogAuthor.getAttribute('content')];
            }

            // Try Twitter Card meta tags
            if (!metadata.title) {
                const twitterTitle = doc.querySelector('meta[name="twitter:title"]');
                if (twitterTitle) metadata.title = twitterTitle.getAttribute('content');
            }
            if (!metadata.description) {
                const twitterDesc = doc.querySelector('meta[name="twitter:description"]');
                if (twitterDesc) metadata.description = twitterDesc.getAttribute('content');
            }

            // Fallback: get title from document title
            if (!metadata.title) {
                metadata.title = doc.title || 'Untitled Article';
            }

            // Extract topics from ArticleTopics section
            const topicsSection = doc.querySelector('section.ArticleTopics');
            if (topicsSection) {
                const topicLinks = topicsSection.querySelectorAll('a.ArticleTopics__ListItemLink');
                const topics = Array.from(topicLinks).map(link => link.textContent.trim());
                if (topics.length > 0) {
                    metadata.topics = topics;
                }
            }
            
            // Also check setTags script tags as fallback
            if (metadata.topics.length === 0) {
                const scriptTags = doc.querySelectorAll('script');
                for (const script of scriptTags) {
                    if (script.textContent && script.textContent.includes('setTags')) {
                        const match = script.textContent.match(/\["setTags"\s*,\s*\[(.*?)\]\]/);
                        if (match) {
                            const tagsStr = match[1];
                            const tags = tagsStr.match(/"([^"]+)"/g);
                            if (tags) {
                                metadata.topics = tags.map(t => t.replace(/"/g, ''));
                                break;
                            }
                        }
                    }
                }
            }

            return metadata;
        }

        function isValidContent(text) {
            if (!text || text.trim().length < 30) return false;
            const lowerText = text.toLowerCase().trim();
            // Reject common error/placeholder messages (but allow longer texts that might contain these words)
            const invalidExactMatches = [
                'you need to enable javascript to run this app',
                'enable javascript to run this app',
                'javascript is required',
                'please enable javascript'
            ];
            // Check for exact matches first
            if (invalidExactMatches.some(pattern => lowerText === pattern || lowerText.startsWith(pattern))) {
                return false;
            }
            // If text is very short and contains error keywords, reject it
            if (text.length < 100) {
                const invalidPatterns = [
                    'enable javascript',
                    'you need to enable',
                    'javascript is disabled'
                ];
                if (invalidPatterns.some(pattern => lowerText.includes(pattern))) {
                    return false;
                }
            }
            // Allow text that contains error keywords if it's long enough (might be legitimate content mentioning these terms)
            return true;
        }

        function extractContentFromEmbeddedData(doc) {
            let content = '';
            
            // Try to find JSON-LD with articleBody
            const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
            for (const script of jsonLdScripts) {
                try {
                    const jsonData = JSON.parse(script.textContent);
                    const data = Array.isArray(jsonData) ? jsonData[0] : jsonData;
                    
                    if ((data['@type'] === 'NewsArticle' || data['@type'] === 'Article')) {
                        if (data.articleBody && isValidContent(data.articleBody)) {
                            content += data.articleBody + '\n\n';
                        }
                        if (data.text && isValidContent(data.text)) {
                            content += data.text + '\n\n';
                        }
                    }
                } catch (e) {
                    // Skip invalid JSON
                }
            }
            
            // Try to find script tags with content data
            const scripts = doc.querySelectorAll('script:not([type="application/ld+json"])');
            for (const script of scripts) {
                const scriptText = script.textContent || '';
                
                // Look for common patterns like window.__INITIAL_STATE__, __NEXT_DATA__, etc.
                const patterns = [
                    /articleBody["\s]*:["\s]*["']([^"']+)["']/gi,
                    /content["\s]*:["\s]*["']([^"']+)["']/gi,
                    /text["\s]*:["\s]*["']([^"']+)["']/gi,
                    /body["\s]*:["\s]*["']([^"']+)["']/gi,
                    /__INITIAL_STATE__\s*=\s*({[^}]*"content"[^}]*})/gi,
                    /__NEXT_DATA__\s*=\s*({[^}]*"props"[^}]*})/gi
                ];
                
                for (const pattern of patterns) {
                    const matches = scriptText.matchAll(pattern);
                    for (const match of matches) {
                        if (match[1] && match[1].length > 50) {
                            try {
                                // Try to parse as JSON first
                                const parsed = JSON.parse(match[1]);
                                if (typeof parsed === 'object' && parsed.content) {
                                    content += parsed.content + '\n\n';
                                } else if (typeof parsed === 'string') {
                                    content += parsed + '\n\n';
                                }
                            } catch (e) {
                                // Not JSON, use as is
                                content += match[1] + '\n\n';
                            }
                        }
                    }
                }
                
                // Try to parse entire script as JSON (for Next.js __NEXT_DATA__, etc.)
                try {
                    // Check for __NEXT_DATA__ pattern (improved regex to handle multiline)
                    if (scriptText.includes('__NEXT_DATA__')) {
                        // Try multiple patterns to catch __NEXT_DATA__
                        let nextDataMatch = scriptText.match(/__NEXT_DATA__\s*=\s*({[\s\S]*?})(?:\s*;|$)/m);
                        if (!nextDataMatch) {
                            nextDataMatch = scriptText.match(/__NEXT_DATA__\s*=\s*({.*})/s);
                        }
                        if (nextDataMatch && nextDataMatch[1]) {
                            const jsonData = JSON.parse(nextDataMatch[1]);
                            const extractContent = (obj, depth = 0, path = '') => {
                                if (depth > 10) return ''; // Prevent infinite recursion, increased depth
                                if (typeof obj === 'string') {
                                    if (obj.length > 100 && isValidContent(obj) && !obj.includes('function(') && !obj.startsWith('http')) {
                                        return obj + '\n\n';
                                    }
                                }
                                if (typeof obj === 'object' && obj !== null) {
                                    let result = '';
                                    for (const key in obj) {
                                        if (['content', 'body', 'text', 'articleBody', 'description', 'excerpt', 'copy', 'summary', 'lead', 'intro'].includes(key)) {
                                            if (typeof obj[key] === 'string' && isValidContent(obj[key])) {
                                                result += obj[key] + '\n\n';
                                            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                                                // Some sites nest content in objects
                                                if (obj[key].html || obj[key].text || obj[key].content) {
                                                    const nested = obj[key].html || obj[key].text || obj[key].content;
                                                    if (typeof nested === 'string' && isValidContent(nested)) {
                                                        result += nested + '\n\n';
                                                    }
                                                }
                                            }
                                        } else if (['paragraphs', 'blocks', 'components', 'sections'].includes(key) && Array.isArray(obj[key])) {
                                            // Handle array of content blocks
                                            obj[key].forEach(item => {
                                                if (typeof item === 'string' && isValidContent(item)) {
                                                    result += item + '\n\n';
                                                } else if (typeof item === 'object' && item !== null) {
                                                    result += extractContent(item, depth + 1, path + '.' + key);
                                                }
                                            });
                                        } else {
                                            result += extractContent(obj[key], depth + 1, path + '.' + key);
                                        }
                                    }
                                    return result;
                                }
                                return '';
                            };
                            const extracted = extractContent(jsonData);
                            if (extracted && isValidContent(extracted)) {
                                content += extracted;
                            }
                        }
                    } else if (scriptText.trim().startsWith('{') || scriptText.trim().startsWith('[')) {
                        // Try to parse as regular JSON
                        const jsonData = JSON.parse(scriptText);
                        if (jsonData.props && jsonData.props.pageProps) {
                            const pageProps = jsonData.props.pageProps;
                            if (pageProps.content) {
                                const cont = typeof pageProps.content === 'string' ? pageProps.content : JSON.stringify(pageProps.content);
                                if (isValidContent(cont)) content += cont + '\n\n';
                            }
                            if (pageProps.article) {
                                const articleContent = pageProps.article.content || pageProps.article.body || pageProps.article.text || '';
                                if (isValidContent(articleContent)) content += articleContent + '\n\n';
                            }
                            if (pageProps.story) {
                                const storyContent = pageProps.story.content || pageProps.story.body || pageProps.story.text || '';
                                if (isValidContent(storyContent)) content += storyContent + '\n\n';
                            }
                        }
                        if (jsonData.content && isValidContent(jsonData.content)) {
                            content += (typeof jsonData.content === 'string' ? jsonData.content : JSON.stringify(jsonData.content)) + '\n\n';
                        }
                        if (jsonData.articleBody && isValidContent(jsonData.articleBody)) {
                            content += jsonData.articleBody + '\n\n';
                        }
                        if (jsonData.body && isValidContent(jsonData.body)) {
                            content += jsonData.body + '\n\n';
                        }
                    }
                } catch (e) {
                    // Not valid JSON, continue
                }
            }
            
            // Try to find data attributes with content
            const dataElements = doc.querySelectorAll('[data-content], [data-body], [data-article], [data-text]');
            for (const elem of dataElements) {
                const text = elem.getAttribute('data-content') || 
                            elem.getAttribute('data-body') || 
                            elem.getAttribute('data-article') ||
                            elem.getAttribute('data-text');
                if (text && isValidContent(text)) {
                    content += text + '\n\n';
                }
            }
            
            // Try to find hidden content in noscript tags
            const noscriptTags = doc.querySelectorAll('noscript');
            for (const noscript of noscriptTags) {
                const noscriptContent = noscript.textContent || noscript.innerHTML;
                if (noscriptContent && isValidContent(noscriptContent)) {
                    content += noscriptContent + '\n\n';
                }
            }
            
            // Look for React/Vue component data in window variables (from script assignments)
            // This is a common pattern: window.__APP_DATA__ = {...}
            const windowVarPatterns = [
                /window\.__APP_DATA__\s*=\s*({[\s\S]*?});/gi,
                /window\.__INITIAL_STATE__\s*=\s*({[\s\S]*?});/gi,
                /window\.__PRELOADED_STATE__\s*=\s*({[\s\S]*?});/gi,
                /window\.articleData\s*=\s*({[\s\S]*?});/gi,
                /window\.contentData\s*=\s*({[\s\S]*?});/gi
            ];
            
            for (const script of scripts) {
                const scriptText = script.textContent || '';
                for (const pattern of windowVarPatterns) {
                    const matches = scriptText.matchAll(pattern);
                    for (const match of matches) {
                        if (match[1]) {
                            try {
                                const jsonData = JSON.parse(match[1]);
                                const extractContent = (obj, depth = 0) => {
                                    if (depth > 8) return '';
                                    if (typeof obj === 'string' && isValidContent(obj)) {
                                        return obj + '\n\n';
                                    }
                                    if (typeof obj === 'object' && obj !== null) {
                                        let result = '';
                                        for (const key in obj) {
                                            if (['content', 'body', 'text', 'articleBody', 'html', 'copy'].includes(key)) {
                                                const val = obj[key];
                                                if (typeof val === 'string' && isValidContent(val)) {
                                                    result += val + '\n\n';
                                                }
                                            } else {
                                                result += extractContent(obj[key], depth + 1);
                                            }
                                        }
                                        return result;
                                    }
                                    return '';
                                };
                                const extracted = extractContent(jsonData);
                                if (extracted) content += extracted;
                            } catch (e) {
                                // Not valid JSON
                            }
                        }
                    }
                }
            }
            
            // Final attempt: Look for any large JSON objects in scripts that might contain article data
            // Some sites embed everything in one large JSON structure
            for (const script of scripts) {
                const scriptText = script.textContent || '';
                if (scriptText.length > 1000 && (scriptText.includes('{') || scriptText.includes('['))) {
                    // Try to find JSON objects that might contain content
                    try {
                        // Look for patterns like var data = {...} or const config = {...}
                        const varPatterns = [
                            /(?:var|let|const)\s+\w+\s*=\s*({[\s\S]{500,}?});/g,
                            /(?:var|let|const)\s+\w+\s*=\s*(\[[\s\S]{500,}?\]);/g
                        ];
                        
                        for (const pattern of varPatterns) {
                            const matches = scriptText.matchAll(pattern);
                            for (const match of matches) {
                                if (match[1]) {
                                    try {
                                        const jsonData = JSON.parse(match[1]);
                                        const extractContent = (obj, depth = 0) => {
                                            if (depth > 10) return '';
                                            if (typeof obj === 'string' && obj.length > 200 && isValidContent(obj)) {
                                                return obj + '\n\n';
                                            }
                                            if (typeof obj === 'object' && obj !== null) {
                                                let result = '';
                                                for (const key in obj) {
                                                    const val = obj[key];
                                                    if (typeof val === 'string' && val.length > 200 && isValidContent(val)) {
                                                        result += val + '\n\n';
                                                    } else if (typeof val === 'object') {
                                                        result += extractContent(val, depth + 1);
                                                    }
                                                }
                                                return result;
                                            }
                                            return '';
                                        };
                                        const extracted = extractContent(jsonData);
                                        if (extracted && isValidContent(extracted)) {
                                            content += extracted;
                                        }
                                    } catch (e) {
                                        // Not valid JSON
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // Continue
                    }
                }
            }
            
            // Validate and clean final content
            const cleaned = content.trim();
            if (cleaned && isValidContent(cleaned)) {
                return cleaned;
            }
            
            return '';
        }

        function preprocessHTMLContent(element) {
            // Remove script, style, meta, link, nav, footer, aside, form, button, iframe
            const unwantedTags = ['script', 'style', 'meta', 'link', 'nav', 'footer', 'aside', 'form', 'button', 'iframe'];
            unwantedTags.forEach(tag => {
                const elements = element.querySelectorAll(tag);
                elements.forEach(el => el.remove());
            });

            // Remove ArticleTopics section
            const topicsSection = element.querySelector('section.ArticleTopics');
            if (topicsSection) {
                topicsSection.remove();
            }

            // Remove promotional content by class/id patterns
            const promotionalClassPatterns = [
                'newsletter', 'subscription', 'signup', 'sign-up', 'cta', 'call-to-action',
                'advertisement', 'ad-', 'promo', 'sponsored', 'recommended', 'related',
                'trending', 'popular', 'sidebar', 'widget', 'social', 'share'
            ];

            const elementsToRemove = [];
            element.querySelectorAll('div, section, aside').forEach(el => {
                const elemClass = (el.className || '').toLowerCase();
                const elemId = (el.id || '').toLowerCase();
                
                if (promotionalClassPatterns.some(pattern => elemClass.includes(pattern) || elemId.includes(pattern))) {
                    elementsToRemove.push(el);
                }
            });
            elementsToRemove.forEach(el => el.remove());

            // Remove promotional paragraphs
            const promotionalTextPatterns = [
                'free newsletter', 'sign up to newsletter', 'sign up to the weekly',
                'advertisement', 'subscribe now', 'join now', 'become a member'
            ];

            const paragraphsToRemove = [];
            element.querySelectorAll('p').forEach(p => {
                const pText = p.textContent.trim().toLowerCase();
                if (promotionalTextPatterns.some(pattern => pText.includes(pattern))) {
                    if (pText.length < 100) {
                        paragraphsToRemove.push(p);
                    }
                }
            });
            paragraphsToRemove.forEach(p => p.remove());

            // Remove promotional headings
            const headingsToRemove = [];
            element.querySelectorAll('h2, h3, h4').forEach(heading => {
                const headingText = heading.textContent.trim().toLowerCase();
                if (promotionalTextPatterns.some(pattern => headingText.includes(pattern))) {
                    headingsToRemove.push(heading);
                }
            });
            headingsToRemove.forEach(h => h.remove());

            // Remove promotional links
            const linksToRemove = [];
            const parentsToRemove = [];
            element.querySelectorAll('a').forEach(link => {
                const href = link.getAttribute('href') || '';
                const linkText = link.textContent.trim();
                const linkTextLower = linkText.toLowerCase();

                const isPromotionalLink = (
                    linkTextLower.startsWith('read more') ||
                    linkTextLower.startsWith('sign up') ||
                    linkTextLower.includes('newsletter') ||
                    linkTextLower.includes('subscribe') ||
                    (linkText.length > 100 && href.includes('/article/'))
                );

                if (isPromotionalLink) {
                    const parent = link.parentElement;
                    if (parent && parent.tagName.toLowerCase() === 'p') {
                        // Check if parent contains images - don't remove if it does
                        const hasImages = parent.querySelector('img') !== null;
                        if (hasImages) {
                            // Remove just the link, not the parent
                            linksToRemove.push(link);
                        } else {
                            const parentText = parent.textContent.trim();
                            if (parentText.length < 200 || parentText === linkText) {
                                parentsToRemove.push(parent);
                            } else {
                                linksToRemove.push(link);
                            }
                        }
                    } else {
                        linksToRemove.push(link);
                    }
                }
            });

            parentsToRemove.forEach(p => p.remove());
            linksToRemove.forEach(link => link.remove());
        }

        function htmlToMarkdown(element, imageMapping, listLevel = 0) {
            if (!element) return '';

            // Text node
            if (element.nodeType === Node.TEXT_NODE) {
                const text = element.textContent.trim();
                // Filter out image credit lines
                if (/^[A-Z][a-z]+\s+Images?\/(Getty|Reuters|Shutterstock|AP|Alamy|iStock)/.test(text)) {
                    return "";
                }
                return text ? text : "";
            }

            // Element node
            if (element.nodeType !== Node.ELEMENT_NODE) return '';

            const tagName = element.tagName.toLowerCase();
            let result = '';

            // Remove unwanted elements
            if (['script', 'style', 'nav', 'footer', 'aside', 'form', 'button', 'iframe'].includes(tagName)) {
                return '';
            }

            // Check for promotional content
            const className = element.className || '';
            const id = element.id || '';
            const promotionalPatterns = ['newsletter', 'subscription', 'signup', 'sign-up', 'advertisement', 'ad-', 'promo'];
            
            if (promotionalPatterns.some(pattern => className.toLowerCase().includes(pattern) || id.toLowerCase().includes(pattern))) {
                return '';
            }

            // Convert elements to markdown
            switch (tagName) {
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                    const level = parseInt(tagName[1]);
                    const headingText = element.textContent.trim();
                    result = '\n' + '#'.repeat(level) + ' ' + headingText + '\n\n';
                    break;

                case 'p':
                    // Check if the paragraph contains block-level elements
                    const hasBlockElements = Array.from(element.children).some(child => 
                        child.nodeType === Node.ELEMENT_NODE && 
                        ['figure', 'table', 'div', 'section', 'ul', 'ol'].includes(child.tagName.toLowerCase())
                    );
                    
                    if (hasBlockElements) {
                        // Process block elements separately, then inline text
                        Array.from(element.childNodes).forEach(child => {
                            if (child.nodeType === Node.ELEMENT_NODE && 
                                ['figure', 'table', 'div', 'section', 'ul', 'ol'].includes(child.tagName.toLowerCase())) {
                                result += htmlToMarkdown(child, imageMapping, listLevel);
                            } else if (child.nodeType === Node.ELEMENT_NODE) {
                                result += processInlineElements(child, imageMapping);
                            } else {
                                result += child.textContent;
                            }
                        });
                        if (result.trim()) {
                            result = result.trim() + '\n\n';
                        }
                    } else {
                        const pText = processInlineElements(element, imageMapping);
                        if (pText.trim()) {
                            result = pText.trim() + '\n\n';
                        }
                    }
                    break;

                case 'br':
                    result = '  \n';
                    break;

                case 'hr':
                    result = '\n---\n\n';
                    break;

                case 'blockquote':
                    const lines = element.textContent.trim().split('\n');
                    result = lines.map(line => '> ' + line).join('\n') + '\n\n';
                    break;

                case 'ul':
                    const ulItems = element.querySelectorAll(':scope > li');
                    ulItems.forEach(li => {
                        const text = processInlineElements(li, imageMapping).trim();
                        result += '  '.repeat(listLevel) + '- ' + text + '\n';
                    });
                    result += '\n';
                    break;

                case 'ol':
                    const olItems = element.querySelectorAll(':scope > li');
                    olItems.forEach((li, idx) => {
                        const text = processInlineElements(li, imageMapping).trim();
                        result += '  '.repeat(listLevel) + `${idx + 1}. ` + text + '\n';
                    });
                    result += '\n';
                    break;

                case 'pre':
                    const codeElem = element.querySelector('code');
                    const code = (codeElem || element).textContent;
                    let lang = '';
                    if (codeElem && codeElem.className) {
                        const match = codeElem.className.match(/language-(\w+)/);
                        if (match) lang = match[1];
                    }
                    result = `\n\`\`\`${lang}\n${code}\n\`\`\`\n\n`;
                    break;

                case 'img':
                    const src = element.getAttribute('src');
                    const alt = element.getAttribute('alt') || 'image';
                    
                    if (src && imageMapping[src]) {
                        const savedFilename = imageMapping[src];
                        
                        // Check if this image is part of a figure with caption
                        let caption_text = "";
                        let figure_title = "";
                        
                        // Check parent elements for captions
                        let parent = element.parentElement;
                        const data_caption = element.getAttribute('data-caption') || '';
                        
                        while (parent && parent.tagName.toLowerCase() !== 'body') {
                            // Look for figcaption elements
                            const figcaption = parent.querySelector('figcaption:not([data-processed="true"])');
                            if (figcaption) {
                                caption_text = figcaption.textContent.trim();
                                // Mark the figcaption as processed to avoid duplication
                                figcaption.setAttribute('data-processed', 'true');
                                break;
                            }
                            
                            // Look for divs with ArticleImageCaption class
                            if (parent.tagName.toLowerCase() === 'div' && parent.className) {
                                const classes = (typeof parent.className === 'string' ? parent.className : Array.from(parent.className).join(' ')).toLowerCase();
                                if (classes.includes('articleimagecaption')) {
                                    // Get title and credit separately from CaptionWrapper
                                    const caption_wrapper = parent.querySelector('div.ArticleImageCaption__CaptionWrapper, .ArticleImageCaption__CaptionWrapper');
                                    if (caption_wrapper) {
                                        const title_elem = caption_wrapper.querySelector('p.ArticleImageCaption__Title, .ArticleImageCaption__Title');
                                        const credit_elem = caption_wrapper.querySelector('p.ArticleImageCaption__Credit, .ArticleImageCaption__Credit');
                                        const caption_parts = [];
                                        if (title_elem) {
                                            caption_parts.push(title_elem.textContent.trim());
                                        }
                                        if (credit_elem) {
                                            const credit_text = credit_elem.textContent.trim();
                                            // Only add credit if it's different from title (to avoid duplicates)
                                            if (credit_text && !caption_parts.join(' ').includes(credit_text)) {
                                                caption_parts.push(credit_text);
                                            }
                                        }
                                        caption_text = caption_parts.join(' ');
                                        break;
                                    }
                                }
                            }
                            
                            // Look for figure elements
                            if (parent.tagName.toLowerCase() === 'figure') {
                                // Check for child figcaption
                                const child_figcaption = parent.querySelector('figcaption:not([data-processed="true"])');
                                if (child_figcaption) {
                                    caption_text = child_figcaption.textContent.trim();
                                    child_figcaption.setAttribute('data-processed', 'true');
                                    break;
                                }
                            }
                            
                            if (parent.parentElement) {
                                parent = parent.parentElement;
                            } else {
                                break;
                            }
                        }
                        
                        // Extract figure title if we have caption
                        if (caption_text) {
                            figure_title = extractFigureTitle(caption_text);
                            const caption_clean = cleanCaption(caption_text);
                            
                            // Format as callout if we have caption information
                            if (caption_text && figure_title) {
                                result = `\n> [!figure]\n`;
                                result += `> ![[${savedFilename}]]\n`;
                                if (caption_clean) {
                                    result += `> <span class="caption caption-left">${caption_clean}</span>\n`;
                                }
                                result += '\n';
                            } else {
                                result = `![[${savedFilename}]]\n\n`;
                            }
                        } else {
                            // Simple image without caption
                            result = `![[${savedFilename}]]\n\n`;
                        }
                    } else if (src) {
                        result = `![${alt}](${src})\n\n`;
                    }
                    break;

                case 'figure':
                    const img = element.querySelector('img');
                    if (img) {
                        result = htmlToMarkdown(img, imageMapping, listLevel);
                    }
                    break;

                case 'table':
                    result = '\n' + convertTable(element) + '\n';
                    break;

                case 'iframe':
                case 'embed':
                case 'object':
                    // Skip iframes, embeds, and objects completely
                    return '';

                case 'div':
                case 'section':
                case 'article':
                case 'main':
                case 'body':
                    // Skip elements that look like image credits (but not if they contain images)
                    const element_text = element.textContent.trim();
                    const has_images = element.querySelector('img') !== null;
                    
                    // Only skip if it looks like a credit line AND has no images
                    if (!has_images) {
                        if (/^[A-Z][a-z]+\s+Images?\/(Getty|Reuters|Shutterstock|AP|Alamy|iStock)/.test(element_text) ||
                            (element_text === element_text.toUpperCase() && element_text.length > 5)) {
                            return "";
                        }
                    }
                    
                    // Process children
                    Array.from(element.childNodes).forEach(child => {
                        // Skip figcaption elements that were already processed with images
                        if (child.nodeType === Node.ELEMENT_NODE && 
                            child.tagName.toLowerCase() === 'figcaption' &&
                            child.getAttribute('data-processed') === 'true') {
                            return;
                        }
                        result += htmlToMarkdown(child, imageMapping, listLevel);
                    });
                    break;

                default:
                    // Process children for container elements
                    Array.from(element.childNodes).forEach(child => {
                        result += htmlToMarkdown(child, imageMapping, listLevel);
                    });
            }

            return result;
        }

        function processInlineElements(element, imageMapping) {
            let result = '';
            
            Array.from(element.childNodes).forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    result += node.textContent;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    const text = processInlineElements(node, imageMapping);
                    
                    switch (tagName) {
                        case 'strong':
                        case 'b':
                            result += `**${text}**`;
                            break;
                        case 'em':
                        case 'i':
                            // Check if this looks like a scientific term (capitalized word)
                            // and wrap in *[[term]]* for Obsidian wikilink formatting
                            if (text && text.split(/\s+/).length === 1 && text[0] && text[0] === text[0].toUpperCase()) {
                                result += `*[[${text}]]*`;
                            } else {
                                result += `*${text}*`;
                            }
                            break;
                        case 'code':
                            result += `\`${text}\``;
                            break;
                        case 'del':
                        case 's':
                        case 'strike':
                            result += `~~${text}~~`;
                            break;
                        case 'mark':
                            result += `==${text}==`;
                            break;
                        case 'sup':
                            result += `^${text}^`;
                            break;
                        case 'sub':
                            result += `~${text}~`;
                            break;
                        case 'a':
                            const href = node.getAttribute('href');
                            if (href) {
                                if (href.includes('/article/') || href.startsWith('/') || href.includes('newscientist.com')) {
                                    if (text && text.length < 100) {
                                        result += `[[${text}]]`;
                                    } else {
                                        result += `[${text}](${href})`;
                                    }
                                } else {
                                    result += `[${text}](${href})`;
                                }
                            } else {
                                result += text;
                            }
                            break;
                        case 'br':
                            result += '  \n';
                            break;
                        case 'img':
                            result += htmlToMarkdown(node, imageMapping, 0);
                            break;
                        default:
                            result += text;
                    }
                }
            });
            
            return result;
        }

        function convertTable(table) {
            const rows = [];
            let hasHeader = false;

            const thead = table.querySelector('thead');
            if (thead) {
                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    const headers = Array.from(headerRow.querySelectorAll('th, td')).map(cell => 
                        cell.textContent.trim().replace(/\|/g, '\\|')
                    );
                    if (headers.length > 0) {
                        rows.push('| ' + headers.join(' | ') + ' |');
                        rows.push('| ' + headers.map(() => '---').join(' | ') + ' |');
                        hasHeader = true;
                    }
                }
            }

            const tbody = table.querySelector('tbody') || table;
            const bodyRows = Array.from(tbody.querySelectorAll('tr')).filter(row => 
                !row.closest('thead')
            );

            let maxCols = 0;
            const allRowsData = [];

            bodyRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td, th')).map(cell =>
                    cell.textContent.trim().replace(/\|/g, '\\|')
                );
                if (cells.length > 0) {
                    allRowsData.push(cells);
                    maxCols = Math.max(maxCols, cells.length);
                }
            });

            if (!hasHeader && allRowsData.length > 0) {
                const headers = Array.from({length: maxCols}, (_, i) => `Column ${i + 1}`);
                rows.push('| ' + headers.join(' | ') + ' |');
                rows.push('| ' + headers.map(() => '---').join(' | ') + ' |');
            }

            allRowsData.forEach(cells => {
                while (cells.length < maxCols) cells.push('');
                rows.push('| ' + cells.join(' | ') + ' |');
            });

            return rows.join('\n');
        }

        function createYAMLFrontmatter(metadata) {
            const lines = ['---'];
            
            lines.push('aliases:');
            if (metadata.title) {
                lines.push(`  - "${metadata.title.replace(/"/g, '\\"')}"`);
            }
            
            if (metadata.authors && metadata.authors.length > 0) {
                lines.push('authors:');
                metadata.authors.forEach(author => {
                    lines.push(`  - "[[${author.replace(/"/g, '\\"')}]]"`);
                });
            }
            
            if (metadata.publication_date) {
                lines.push(`publication_date: "${metadata.publication_date}"`);
            }
            
            if (metadata.title) {
                lines.push(`title: "${metadata.title.replace(/"/g, '\\"')}"`);
            }
            
            // Topics (from setTags and category)
            const topics = [];
            if (metadata.topics && metadata.topics.length > 0) {
                // Capitalize each topic for consistency
                topics.push(...metadata.topics.map(tag => {
                    return tag.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
                }));
            }
            if (metadata.category && !topics.includes(metadata.category)) {
                topics.push(metadata.category);
            }
            
            if (topics.length > 0) {
                lines.push('topics:');
                topics.forEach(topic => {
                    lines.push(`  - "[[${topic.replace(/"/g, '\\"')}]]"`);
                });
            }
            
            lines.push('types:');
            lines.push('  - "[[TYPE - Article]]"');
            
            if (metadata.url) {
                lines.push('url:');
                lines.push(`  - "${metadata.url}"`);
            }
            
            lines.push('---');
            lines.push('');
            
            return lines.join('\n');
        }

        // --------------------MAIN CONVERSION FUNCTION
        
        // Store processed data for download again functionality
        let lastProcessedData = null;
        let lastFolderHandle = null;

        async function saveFilesToFolder(folderHandle, outputData) {
            const { timestamp, sanitizedTitle, fullMarkdown, images, summary } = outputData;
            
            try {
                // Create main output folder
                const outputFolderName = `[${timestamp}] - Web URL To Obsidian Markdown - (${sanitizedTitle})`;
                let outputFolderHandle;
                
                try {
                    outputFolderHandle = await folderHandle.getDirectoryHandle(outputFolderName, { create: true });
                } catch (error) {
                    // If folder already exists, open it
                    outputFolderHandle = await folderHandle.getDirectoryHandle(outputFolderName);
                }

                addStatus(`Saving files to folder: ${outputFolderName}`, 'info');
                updateProgress(90);

                // Save markdown file
                const markdownFilename = `[${timestamp}] - ${sanitizedTitle}.md`;
                const markdownFileHandle = await outputFolderHandle.getFileHandle(markdownFilename, { create: true });
                const markdownWritable = await markdownFileHandle.createWritable();
                await markdownWritable.write('\ufeff' + fullMarkdown);
                await markdownWritable.close();
                addStatus(`Saved: ${markdownFilename}`, 'success');

                // Save images to Figures subfolder
                if (images && images.length > 0) {
                    let figuresFolderHandle;
                    try {
                        figuresFolderHandle = await outputFolderHandle.getDirectoryHandle('Figures', { create: true });
                    } catch (error) {
                        figuresFolderHandle = await outputFolderHandle.getDirectoryHandle('Figures');
                    }

                    addStatus(`Saving ${images.length} images...`, 'info');
                    for (let i = 0; i < images.length; i++) {
                        const img = images[i];
                        const imageFileHandle = await figuresFolderHandle.getFileHandle(img.filename, { create: true });
                        const imageWritable = await imageFileHandle.createWritable();
                        await imageWritable.write(img.blob);
                        await imageWritable.close();
                        updateProgress(90 + (i + 1) / images.length * 5);
                    }
                    addStatus(`Saved ${images.length} images to Figures folder`, 'success');
                }

                // Save summary
                const summaryFilename = `[${timestamp}] - summary.json`;
                const summaryFileHandle = await outputFolderHandle.getFileHandle(summaryFilename, { create: true });
                const summaryWritable = await summaryFileHandle.createWritable();
                await summaryWritable.write(JSON.stringify(summary, null, 2));
                await summaryWritable.close();
                addStatus(`Saved: ${summaryFilename}`, 'success');

                return outputFolderHandle;
            } catch (error) {
                throw new Error(`Failed to save files: ${error.message}`);
            }
        }

        async function downloadFilesToFolder(outputData, folderHandle = null) {
            try {
                // Check if File System Access API is supported
                if ('showDirectoryPicker' in window) {
                    // Use provided folder handle if available, otherwise request one
                    if (!folderHandle) {
                        addStatus('Select a folder to save the files...', 'info');
                        folderHandle = await window.showDirectoryPicker();
                        lastFolderHandle = folderHandle;
                    }
                    
                    await saveFilesToFolder(folderHandle, outputData);
                    addStatus('All files saved successfully!', 'success');
                    return true;
                } else {
                    // Fallback: Download files individually
                    addStatus('File System Access API not supported. Downloading files individually...', 'warning');
                    return await downloadFilesIndividually(outputData);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    addStatus('Folder selection cancelled', 'info');
                    return false;
                }
                addStatus(`Error: ${error.message}`, 'error');
                // Fallback to individual downloads
                return await downloadFilesIndividually(outputData);
            }
        }

        async function downloadFilesIndividually(outputData) {
            const { timestamp, sanitizedTitle, fullMarkdown, images, summary } = outputData;
            const outputFolderName = `[${timestamp}] - Web URL To Obsidian Markdown - (${sanitizedTitle})`;
            
            try {
                // Download markdown
                const markdownFilename = `[${timestamp}] - ${sanitizedTitle}.md`;
                const markdownBlob = new Blob(['\ufeff' + fullMarkdown], { type: 'text/markdown;charset=utf-8' });
                saveAs(markdownBlob, markdownFilename);

                // Download images
                if (images && images.length > 0) {
                    addStatus(`Downloading ${images.length} images...`, 'info');
                    for (const img of images) {
                        saveAs(img.blob, img.filename);
                    }
                }

                // Download summary
                const summaryFilename = `[${timestamp}] - summary.json`;
                const summaryBlob = new Blob([JSON.stringify(summary, null, 2)], { type: 'application/json' });
                saveAs(summaryBlob, summaryFilename);

                addStatus('All files downloaded! Create a folder and organize them manually.', 'success');
                addStatus(`Folder name: ${outputFolderName}`, 'info');
                addStatus(`Files: ${markdownFilename}, ${images.length} images, ${summaryFilename}`, 'info');
                return true;
            } catch (error) {
                addStatus(`Error downloading files: ${error.message}`, 'error');
                return false;
            }
        }

        async function fetchWithCorsFallback(url, useProxy = false) {
            // Always use proxy if running from file://, otherwise respect the useProxy flag
            const needsProxy = isLocalFile || useProxy;
            
            if (!needsProxy && !isLocalFile) {
                // Try direct fetch first
                try {
                    addStatus('Trying direct fetch...', 'info');
                    const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });
                    
                    if (response.ok) {
                        const text = await response.text();
                        addStatus('Direct fetch successful', 'success');
                        return text;
                    }
                } catch (error) {
                    addStatus('Direct fetch failed, trying CORS proxy...', 'warning');
                }
            }

            // Try each proxy in sequence
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxy = CORS_PROXIES[i];
                try {
                    let proxyUrl = proxy + encodeURIComponent(url);
                    const isJsonResponse = proxy.includes('/get?');
                    
                    addStatus(`Trying CORS proxy ${i + 1}/${CORS_PROXIES.length} (${proxy.split('/')[2] || 'proxy'})...`, 'info');
                    
                    // Use no-cors mode as last resort, but this limits response reading
                    const fetchOptions = {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
                        }
                    };
                    
                    let response;
                    try {
                        response = await fetch(proxyUrl, fetchOptions);
                    } catch (fetchError) {
                        // If CORS fails, try with no-cors (but we won't be able to read response properly)
                        if (fetchError.message.includes('CORS')) {
                            throw new Error('CORS blocked by browser');
                        }
                        throw fetchError;
                    }
                    
                    if (response.ok) {
                        let text;
                        
                        // Handle JSON-wrapped responses (like allorigins.win/get)
                        if (isJsonResponse) {
                            try {
                                const json = await response.json();
                                text = json.contents || json.content || json.data || JSON.stringify(json);
                                // If it's still JSON string, try parsing
                                if (typeof text === 'string' && text.startsWith('{')) {
                                    try {
                                        const parsed = JSON.parse(text);
                                        text = parsed.contents || parsed.content || parsed.data || text;
                                    } catch (e) {
                                        // Keep original text
                                    }
                                }
                            } catch (jsonError) {
                                // Fall back to text
                                text = await response.text();
                            }
                        } else {
                            text = await response.text();
                        }
                        
                        // Check if we got HTML (not an error page)
                        if (text && (text.includes('<!DOCTYPE') || text.includes('<html') || text.length > 500)) {
                            addStatus(`CORS proxy ${i + 1} successful`, 'success');
                            return text;
                        } else {
                            throw new Error('Proxy returned non-HTML content');
                        }
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    const errorMsg = error.message || String(error);
                    addStatus(`Proxy ${i + 1} failed: ${errorMsg}`, 'warning');
                    
                    // If this was a CORS error and we're on the last proxy, provide helpful message
                    if (i === CORS_PROXIES.length - 1) {
                        if (errorMsg.includes('CORS') || errorMsg.includes('blocked')) {
                            throw new Error(`All CORS proxies blocked by browser security. ${isLocalFile ? 'Consider running this HTML file via a local web server (e.g., Python: python -m http.server) to avoid CORS restrictions.' : 'Try enabling "Use CORS Proxy" checkbox.'}`);
                        }
                        throw new Error(`All CORS proxies failed. Last error: ${errorMsg}`);
                    }
                    // Continue to next proxy
                }
            }
            
            throw new Error('All fetch methods failed');
        }

        async function downloadImage(url, filename) {
            // Try direct fetch first, then fall back to proxies if needed
            const tryFetch = async (fetchUrl) => {
                const response = await fetch(fetchUrl, {
                    method: 'GET',
                    mode: 'cors'
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.blob();
            };

            try {
                // Try direct fetch
                const blob = await tryFetch(url);
                return { filename, blob };
            } catch (error) {
                // If direct fetch fails and we're using proxies, try with proxy
                if (isLocalFile || document.getElementById('useCorsProxy').checked) {
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const proxyUrl = proxy + encodeURIComponent(url);
                            const blob = await tryFetch(proxyUrl);
                            return { filename, blob };
                        } catch (proxyError) {
                            // Try next proxy
                            continue;
                        }
                    }
                }
                addStatus(`Failed to download image: ${url.substring(0, 60)}...`, 'warning');
                return null;
            }
        }

        async function convertWebpageToMarkdown(url, options) {
            clearStatus();
            updateProgress(5);
            addStatus('Starting conversion...', 'info');

            let htmlContent;
            let sourceUrl = url;

            // Check if HTML is provided directly
            if (options.htmlContent) {
                addStatus('Using provided HTML source code...', 'info');
                htmlContent = options.htmlContent;
                sourceUrl = options.sourceUrl || 'pasted-html-source';
                updateProgress(15);
            } else {
                // Fetch the webpage with CORS fallback
                addStatus(`Target URL: ${url}`, 'info');
                try {
                    htmlContent = await fetchWithCorsFallback(url, options.useCorsProxy);
                    updateProgress(15);
                } catch (error) {
                    addStatus(`Failed to fetch webpage: ${error.message}`, 'error');
                    addStatus('Tip: Enable "Use CORS Proxy" checkbox and try again', 'info');
                    throw error;
                }
            }

            updateProgress(20);

            // Parse HTML
            addStatus('Parsing HTML content...', 'info');
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');

            // Extract metadata
            addStatus('Extracting metadata...', 'info');
            const metadata = extractMetadata(doc, sourceUrl);
            addStatus(`Title: ${metadata.title}`, 'info');
            updateProgress(30);

            // Find article content
            let articleContent = null;
            for (const selector of ARTICLE_SELECTORS) {
                articleContent = doc.querySelector(selector);
                if (articleContent) {
                    addStatus(`Found article content using: ${selector}`, 'info');
                    break;
                }
            }

            // Try to extract content from embedded JSON/data if no article content found or content is too short
            const contentText = articleContent ? articleContent.textContent.trim() : '';
            const hasMinimalContent = !articleContent || contentText.length < 100 || 
                                      contentText.toLowerCase().includes('enable javascript') ||
                                      contentText.toLowerCase().includes('you need to enable javascript') ||
                                      !isValidContent(contentText);
            
            if (hasMinimalContent) {
                addStatus('Trying to extract content from embedded data...', 'info');
                const extractedContent = extractContentFromEmbeddedData(doc);
                
                // Only use extracted content if it's valid and substantial
                if (extractedContent && isValidContent(extractedContent) && extractedContent.length > 100) {
                    // Create a temporary div with the extracted content
                    const tempDiv = doc.createElement('div');
                    tempDiv.className = 'extracted-content';
                    
                    // Check if content is HTML or plain text
                    if (extractedContent.includes('<') && extractedContent.includes('>') && extractedContent.includes('<p')) {
                        // It's HTML, parse it - but remove iframes first
                        let cleanContent = extractedContent
                            .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '')
                            .replace(/<iframe[^>]*\/?>/gi, '')
                            .replace(/<embed[^>]*>.*?<\/embed>/gi, '')
                            .replace(/<embed[^>]*\/?>/gi, '')
                            .replace(/<object[^>]*>.*?<\/object>/gi, '');
                        tempDiv.innerHTML = cleanContent;
                    } else {
                        // It's plain text, wrap in paragraphs
                        const paragraphs = extractedContent.split('\n\n').filter(p => p.trim().length > 20);
                        if (paragraphs.length > 0) {
                            paragraphs.forEach(p => {
                                const para = doc.createElement('p');
                                para.textContent = p.trim();
                                tempDiv.appendChild(para);
                            });
                        } else {
                            // Single paragraph
                            const para = doc.createElement('p');
                            para.textContent = extractedContent.trim();
                            tempDiv.appendChild(para);
                        }
                    }
                    
                    // Verify the parsed content has substantial text
                    const parsedText = tempDiv.textContent.trim();
                    if (parsedText.length > 100 && isValidContent(parsedText)) {
                        articleContent = tempDiv;
                        addStatus('Content extracted from embedded data', 'success');
                    } else {
                        addStatus('Extracted content appears invalid, keeping original', 'warning');
                    }
                } else {
                    if (extractedContent) {
                        addStatus('Extracted content too short or invalid', 'warning');
                    } else {
                        addStatus('No content found in embedded data', 'warning');
                    }
                }
            }

            // Final fallback: Try to extract visible text from body if we still have minimal content
            const finalContentText = articleContent ? articleContent.textContent.trim() : '';
            if (!articleContent || finalContentText.length < 100 || !isValidContent(finalContentText)) {
                addStatus('Extracting visible text content as fallback...', 'info');
                const body = doc.querySelector('body');
                if (body) {
                    // Clone body to avoid modifying original
                    const bodyClone = body.cloneNode(true);
                    
                    // Remove all script, style, nav, footer, aside, iframe elements
                    const unwanted = bodyClone.querySelectorAll('script, style, nav, footer, aside, iframe, embed, object, .ad, .advertisement, .sidebar, .menu, header, [id*="ad"], [class*="ad"]');
                    unwanted.forEach(el => el.remove());
                    
                    // Try to find the main content area
                    const mainContent = bodyClone.querySelector('main, [role="main"], .main, #main, #content, .content, #app, #root, [id*="app"], [id*="root"]');
                    if (mainContent) {
                        const mainText = mainContent.textContent.trim();
                        if (mainText.length > 100 && isValidContent(mainText)) {
                            articleContent = mainContent;
                            addStatus('Found content in main area', 'success');
                        }
                    }
                    
                    // If still no good content, try the cloned body
                    if (!articleContent || articleContent.textContent.trim().length < 100) {
                        const bodyText = bodyClone.textContent.trim();
                        if (bodyText.length > 100 && isValidContent(bodyText)) {
                            articleContent = bodyClone;
                            addStatus('Using body content as fallback', 'info');
                        }
                    }
                }
            }
            
            if (!articleContent) {
                addStatus('No specific article section found, using full body', 'warning');
                articleContent = doc.querySelector('body') || doc.documentElement;
            }
            
            // Final check: If content is still minimal/invalid, add a note
            const finalText = articleContent.textContent.trim();
            if (finalText.length < 100 || !isValidContent(finalText)) {
                addStatus('‚ö†Ô∏è Warning: Content appears minimal. This may be a JavaScript-dependent interactive page.', 'warning');
                addStatus('The page content may need to be loaded dynamically via JavaScript.', 'warning');
            }

            // Preprocess: Remove unwanted elements (matching Python script)
            addStatus('Preprocessing HTML...', 'info');
            preprocessHTMLContent(articleContent);
            
            // Final cleanup: Remove any remaining iframes, embeds, objects
            const remainingIframes = articleContent.querySelectorAll('iframe, embed, object');
            remainingIframes.forEach(el => el.remove());

            updateProgress(40);

            // Download images
            const imageMapping = {};
            let imageCounter = 1;
            const normalizedTitle = normalizeTitle(metadata.title, 50, options.prefix || 'ARTICLE - ');
            const sanitizedTitle = sanitizeFilename(normalizedTitle);
            let downloadedImages = [];

            if (options.downloadImages) {
                addStatus('Downloading images...', 'info');
                const images = articleContent.querySelectorAll('img');
                const imagePromises = [];

                images.forEach(img => {
                    let src = img.getAttribute('src');
                    if (!src) return;

                    // Resolve relative URLs (only if we have a valid base URL)
                    if (sourceUrl && sourceUrl !== 'pasted-html-source') {
                        try {
                            if (src.startsWith('//')) {
                                src = 'https:' + src;
                            } else if (src.startsWith('/')) {
                                const urlObj = new URL(sourceUrl);
                                src = `${urlObj.protocol}//${urlObj.host}${src}`;
                            } else if (!src.startsWith('http')) {
                                src = new URL(src, sourceUrl).href;
                            }
                        } catch (e) {
                            // If URL resolution fails, try to keep the src as is if it's already absolute
                            if (!src.startsWith('http')) {
                                addStatus(`Warning: Could not resolve relative image URL: ${src}`, 'warning');
                            }
                        }
                    } else {
                        // For pasted HTML without a base URL, we can only handle absolute URLs
                        if (!src.startsWith('http') && !src.startsWith('//')) {
                            addStatus(`Warning: Relative image URL cannot be resolved without base URL: ${src}`, 'warning');
                        }
                    }

                    // Determine extension
                    let extension = '.jpg';
                    try {
                        const urlPath = new URL(src).pathname;
                        const ext = urlPath.substring(urlPath.lastIndexOf('.')).toLowerCase();
                        if (IMAGE_EXTENSIONS.includes(ext)) {
                            extension = ext;
                        }
                    } catch (e) {}

                    const filename = `${sanitizedTitle} - Fig${String(imageCounter).padStart(4, '0')}${extension}`;
                    imagePromises.push(
                        downloadImage(src, filename).then(result => {
                            if (result) {
                                imageMapping[src] = result.filename;
                                return result;
                            }
                            return null;
                        })
                    );
                    imageCounter++;
                });

                downloadedImages = (await Promise.all(imagePromises)).filter(img => img !== null);
                addStatus(`Downloaded ${downloadedImages.length} images`, 'success');
                updateProgress(60);
            }

            // Store downloaded images for later use (avoid re-downloading)
            const allImages = downloadedImages;

            // Convert to Markdown
            addStatus('Converting HTML to Markdown...', 'info');
            let markdownContent = htmlToMarkdown(articleContent, imageMapping);
            
            // Check if content is too minimal - add a note if so
            const wordCount = markdownContent.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount < 50) {
                const note = '\n\n> ‚ö†Ô∏è **Note**: This appears to be a JavaScript-dependent interactive page. The actual content may be loaded dynamically and not available in the static HTML. Consider accessing this page directly in a browser to view the full interactive content.\n';
                markdownContent = note + markdownContent;
            }
            
            // Clean up excessive newlines
            markdownContent = markdownContent.replace(/\n{3,}/g, '\n\n');
            
            // Post-process to remove image credit lines and unwanted HTML tags (matching Python script)
            const lines = markdownContent.split('\n');
            const cleaned_lines = [];
            for (const line of lines) {
                // Skip lines that are just image credits
                if (/^[A-Z][a-z]+\s+Images?\/(Getty|Reuters|Shutterstock|AP|Alamy|iStock|Photo)/.test(line.trim())) {
                    continue;
                }
                
                // Remove iframe, embed, object tags (handle both self-closing and paired tags)
                let cleanedLine = line;
                // Remove iframes (both <iframe></iframe> and <iframe />)
                cleanedLine = cleanedLine.replace(/<iframe[^>]*>.*?<\/iframe>/gis, '');
                cleanedLine = cleanedLine.replace(/<iframe[^>]*\s*\/?>/gi, '');
                // Remove embeds
                cleanedLine = cleanedLine.replace(/<embed[^>]*>.*?<\/embed>/gis, '');
                cleanedLine = cleanedLine.replace(/<embed[^>]*\s*\/?>/gi, '');
                // Remove objects
                cleanedLine = cleanedLine.replace(/<object[^>]*>.*?<\/object>/gis, '');
                cleanedLine = cleanedLine.replace(/<object[^>]*\s*\/?>/gi, '');
                
                // Remove image credits from the end of lines (before they were split)
                cleanedLine = cleanedLine.replace(/[A-Z][a-z]+\s+Images?\/Getty.*$/, '');
                cleanedLine = cleanedLine.replace(/Images?$/, '').trim();  // Remove trailing "Images"
                
                // Skip empty lines after cleaning
                if (cleanedLine.trim()) {
                    cleaned_lines.push(cleanedLine);
                }
            }
            
            markdownContent = cleaned_lines.join('\n');
            markdownContent = markdownContent.replace(/\n{3,}/g, '\n\n').trim();
            
            updateProgress(75);

            // Create frontmatter
            const frontmatter = createYAMLFrontmatter(metadata);
            const fullMarkdown = frontmatter + `# ${metadata.title}\n\n` + markdownContent;

            updateProgress(85);

            // Create summary
            const timestamp = getTimestamp();
            const summary = {
                script_name: 'Web_URL_To_Obsidian_Markdown_Converter.html',
                timestamp: timestamp,
                source_url: sourceUrl,
                source_type: options.htmlContent ? 'pasted_html' : 'url',
                output_description: 'Web URL To Obsidian Markdown Converter',
                metadata: metadata,
                statistics: {
                    num_images: Object.keys(imageMapping).length,
                    num_words: markdownContent.split(/\s+/).length,
                    num_lines: markdownContent.split('\n').length,
                    markdown_size_kb: (new Blob([fullMarkdown]).size / 1024).toFixed(2)
                }
            };

            // Store processed data for download again
            const outputData = {
                timestamp,
                sanitizedTitle,
                fullMarkdown,
                images: allImages,
                summary
            };
            lastProcessedData = outputData;

            updateProgress(90);

            // Save files to folder
            addStatus('Saving files to folder...', 'info');
            await downloadFilesToFolder(outputData, options.folderHandle);
            
            updateProgress(100);
            addStatus('Conversion completed successfully!', 'success');
            addStatus(`Total images: ${Object.keys(imageMapping).length}`, 'info');
            addStatus(`Word count: ${summary.statistics.num_words.toLocaleString()}`, 'info');

            // Show download again button
            document.getElementById('downloadAgainBtn').style.display = 'inline-block';

            return { markdown: fullMarkdown, metadata, summary, outputData };
        }

        // --------------------EVENT HANDLERS

        // Toggle between URL and HTML input modes
        document.getElementById('useHtmlMode').addEventListener('change', (e) => {
            const useHtmlMode = e.target.checked;
            const urlContainer = document.getElementById('urlInputContainer');
            const htmlContainer = document.getElementById('htmlInputContainer');
            const corsProxyContainer = document.getElementById('corsProxyContainer');
            const urlInput = document.getElementById('urlInput');
            const htmlInput = document.getElementById('htmlInput');

            if (useHtmlMode) {
                urlContainer.classList.add('hidden');
                htmlContainer.classList.add('active');
                corsProxyContainer.style.display = 'none';
                urlInput.removeAttribute('required');
                htmlInput.setAttribute('required', 'required');
            } else {
                urlContainer.classList.remove('hidden');
                htmlContainer.classList.remove('active');
                corsProxyContainer.style.display = 'flex';
                urlInput.setAttribute('required', 'required');
                htmlInput.removeAttribute('required');
            }
        });

        document.getElementById('converterForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const useHtmlMode = document.getElementById('useHtmlMode').checked;
            const url = document.getElementById('urlInput').value.trim();
            const htmlContent = document.getElementById('htmlInput').value.trim();
            const prefix = document.getElementById('prefixInput').value.trim();
            const downloadImages = document.getElementById('downloadImages').checked;
            const useCorsProxy = document.getElementById('useCorsProxy').checked;

            if (useHtmlMode) {
                if (!htmlContent) {
                    alert('Please paste HTML source code');
                    return;
                }
            } else {
                if (!url) {
                    alert('Please enter a valid URL');
                    return;
                }
            }

            const convertBtn = document.getElementById('convertBtn');
            const downloadAgainBtn = document.getElementById('downloadAgainBtn');
            convertBtn.disabled = true;
            convertBtn.textContent = 'Processing...';
            downloadAgainBtn.style.display = 'none'; // Hide while processing new conversion

            // Request folder handle immediately while user gesture is active
            let folderHandle = null;
            if ('showDirectoryPicker' in window) {
                try {
                    addStatus('Select a folder to save the files...', 'info');
                    folderHandle = await window.showDirectoryPicker();
                    lastFolderHandle = folderHandle;
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        addStatus('Folder selection cancelled or failed, will download files individually', 'warning');
                    } else {
                        addStatus('Folder selection cancelled', 'info');
                        convertBtn.disabled = false;
                        convertBtn.textContent = 'Convert & Download';
                        return;
                    }
                }
            }

            try {
                const conversionOptions = {
                    prefix: prefix,
                    downloadImages: downloadImages,
                    useCorsProxy: useCorsProxy,
                    folderHandle: folderHandle
                };

                if (useHtmlMode) {
                    // Extract URL from HTML if available (from meta tags or base tag)
                    let extractedUrl = null;
                    try {
                        const tempDoc = new DOMParser().parseFromString(htmlContent, 'text/html');
                        const ogUrl = tempDoc.querySelector('meta[property="og:url"]');
                        if (ogUrl) {
                            extractedUrl = ogUrl.getAttribute('content');
                        } else {
                            const baseTag = tempDoc.querySelector('base[href]');
                            if (baseTag) {
                                extractedUrl = baseTag.getAttribute('href');
                            } else {
                                const canonicalLink = tempDoc.querySelector('link[rel="canonical"]');
                                if (canonicalLink) {
                                    extractedUrl = canonicalLink.getAttribute('href');
                                }
                            }
                        }
                    } catch (e) {
                        // Ignore errors in URL extraction
                    }

                    conversionOptions.htmlContent = htmlContent;
                    conversionOptions.sourceUrl = extractedUrl || 'pasted-html-source';
                    await convertWebpageToMarkdown('', conversionOptions);
                } else {
                    await convertWebpageToMarkdown(url, conversionOptions);
                }
            } catch (error) {
                addStatus(`Error: ${error.message}`, 'error');
                console.error('Conversion error:', error);
            } finally {
                convertBtn.disabled = false;
                convertBtn.textContent = 'Convert & Download';
            }
        });

        // Download Again button handler
        document.getElementById('downloadAgainBtn').addEventListener('click', async () => {
            if (!lastProcessedData) {
                addStatus('No processed data available. Please convert an article first.', 'error');
                return;
            }

            const downloadBtn = document.getElementById('downloadAgainBtn');
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'Downloading...';

            clearStatus();
            updateProgress(0);
            addStatus('Downloading files again...', 'info');

            try {
                let folderHandle = lastFolderHandle;
                
                // Request a folder handle immediately (while user gesture is active)
                // We'll try to use the previous one first, but have a new one ready if it fails
                if ('showDirectoryPicker' in window && !folderHandle) {
                    addStatus('Select a folder to save the files...', 'info');
                    folderHandle = await window.showDirectoryPicker();
                    lastFolderHandle = folderHandle;
                } else if (folderHandle) {
                    addStatus('Using previous folder...', 'info');
                }
                
                try {
                    await downloadFilesToFolder(lastProcessedData, folderHandle);
                    addStatus('Files saved successfully!', 'success');
                } catch (saveError) {
                    // If using previous handle failed, request a new one (still within user gesture context)
                    if (folderHandle === lastFolderHandle && lastFolderHandle && 'showDirectoryPicker' in window) {
                        addStatus('Previous folder unavailable, selecting new folder...', 'warning');
                        folderHandle = await window.showDirectoryPicker();
                        lastFolderHandle = folderHandle;
                        await downloadFilesToFolder(lastProcessedData, folderHandle);
                        addStatus('Files saved successfully!', 'success');
                    } else {
                        throw saveError;
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    addStatus('Folder selection cancelled', 'info');
                } else {
                    addStatus(`Error: ${error.message}`, 'error');
                    console.error('Download error:', error);
                }
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'Download Again';
                updateProgress(100);
            }
        });

        // Add some helpful info on load
        window.addEventListener('load', () => {
            // Set initial required attribute for URL input
            document.getElementById('urlInput').setAttribute('required', 'required');
            
            // Auto-check CORS proxy if running from file://
            if (isLocalFile) {
                document.getElementById('useCorsProxy').checked = true;
                const warningDiv = document.getElementById('corsWarning');
                warningDiv.innerHTML = '<strong>‚ÑπÔ∏è Running from local file</strong><br>CORS proxy is automatically enabled for local files. All requests will use proxy services.';
                warningDiv.style.background = '#eff6ff';
                warningDiv.style.borderLeftColor = '#3b82f6';
                warningDiv.style.color = '#1e40af';
            }
            addStatus('Ready to convert web articles to Obsidian Markdown', 'success');
        });
    </script>
</body>
</html>


